{
    "docs": [
        {
            "location": "/", 
            "text": "zend-mail\n\n\n\n\n\n\nZend\\Mail\n provides generalized functionality to compose and send both text and\nMIME-compliant multipart email messages. Mail can be sent with \nZend\\Mail\n via\nthe \nMail\\Transport\\Sendmail\n, \nMail\\Transport\\Smtp\n or the \nMail\\Transport\\File\n\ntransport. Of course, you can also implement your own transport by implementing\nthe \nMail\\Transport\\TransportInterface\n.\n\n\n\n\nFile issues at https://github.com/zendframework/zend-mail/issues\n\n\nDocumentation is at https://zendframework.github.io/zend-mail/", 
            "title": "Home"
        }, 
        {
            "location": "/#zend-mail", 
            "text": "Zend\\Mail  provides generalized functionality to compose and send both text and\nMIME-compliant multipart email messages. Mail can be sent with  Zend\\Mail  via\nthe  Mail\\Transport\\Sendmail ,  Mail\\Transport\\Smtp  or the  Mail\\Transport\\File \ntransport. Of course, you can also implement your own transport by implementing\nthe  Mail\\Transport\\TransportInterface .   File issues at https://github.com/zendframework/zend-mail/issues  Documentation is at https://zendframework.github.io/zend-mail/", 
            "title": "zend-mail"
        }, 
        {
            "location": "/intro/", 
            "text": "Introduction\n\n\nzend-mail provides generalized functionality to compose and send both text and\nMIME-compliant multipart email messages. Mail can be sent with zend-mail via any\nof the Sendmail, SMTP, or file-based transports it defines.  You can also\nimplement your own transport by implementing the\n\nZend\\Mail\\Transport\\TransportInterface\n.\n\n\nBasic email\n\n\nA basic email consists of one or more recipients, a subject, a body and a\nsender. To send such a mail using \nZend\\Mail\\Transport\\Sendmail\n, do the\nfollowing:\n\n\nuse Zend\\Mail;\n\n$mail = new Mail\\Message();\n$mail-\nsetBody('This is the text of the email.');\n$mail-\nsetFrom('Freeaqingme@example.org', \nSender's name\n);\n$mail-\naddTo('Matthew@example.com', 'Name of recipient');\n$mail-\nsetSubject('TestSubject');\n\n$transport = new Mail\\Transport\\Sendmail();\n$transport-\nsend($mail);\n\n\n\n\n\n\nMinimum definitions\n\n\nIn order to send an email using zend-mail you have to specify at least one\nrecipient as well as a message body. Please note that each transport may\nrequire additional parameters to be set.\n\n\n\n\nFor most mail attributes there are \"get\" methods to read the information stored\nin the message object. for further details, please refer to the API\ndocumentation.\n\n\nConfiguring the default sendmail transport\n\n\nThe default transport is \nZend\\Mail\\Transport\\Sendmail\n. It is a wrapper to the\nPHP \nmail()\n function. If you wish to pass additional\nparameters to the \nmail()\n function, create a new transport\ninstance and pass your parameters to the constructor.\n\n\nPassing additional mail() parameters\n\n\nThis example shows how to change the Return-Path of the\n\nmail()\n function.\n\n\nuse Zend\\Mail;\n\n$mail = new Mail\\Message();\n$mail-\nsetBody('This is the text of the email.');\n$mail-\nsetFrom('Freeaqingme@example.org', 'Dolf');\n$mail-\naddTo('matthew@example.com', 'Matthew');\n$mail-\nsetSubject('TestSubject');\n\n$transport = new Mail\\Transport\\Sendmail('-freturn_to_me@example.com');\n$transport-\nsend($mail);\n\n\n\n\n\n\nChose your transport wisely\n\n\nAlthough the sendmail transport is the transport that requires least\nconfiguration, it may not be suitable for your production environment. This is\nbecause emails sent using the sendmail transport will be more often delivered\nto SPAM-boxes. This can partly be remedied by using the\n\nSMTP Transport\n combined with an SMTP\nserver that has an overall good reputation. Additionally, techniques such as\nSPF and DKIM may be employed to ensure even more email messages are delivered\nsuccessfully.\n\n\nWarning: Sendmail Transport and Windows\n\n\nAs the PHP manual states, the \nmail()\n function has different behaviour on\nWindows than it does on *nix based systems. Using the sendmail transport on\nWindows will not work in combination with \naddBcc()\n.  The \nmail()\n function\nwill send to the BCC recipient such that all the other recipients can see that\naddress as the recipient!\n\n\nTherefore if you want to use BCC on a windows server, use the SMTP transport\nfor sending!", 
            "title": "Intro"
        }, 
        {
            "location": "/intro/#introduction", 
            "text": "zend-mail provides generalized functionality to compose and send both text and\nMIME-compliant multipart email messages. Mail can be sent with zend-mail via any\nof the Sendmail, SMTP, or file-based transports it defines.  You can also\nimplement your own transport by implementing the Zend\\Mail\\Transport\\TransportInterface .", 
            "title": "Introduction"
        }, 
        {
            "location": "/intro/#basic-email", 
            "text": "A basic email consists of one or more recipients, a subject, a body and a\nsender. To send such a mail using  Zend\\Mail\\Transport\\Sendmail , do the\nfollowing:  use Zend\\Mail;\n\n$mail = new Mail\\Message();\n$mail- setBody('This is the text of the email.');\n$mail- setFrom('Freeaqingme@example.org',  Sender's name );\n$mail- addTo('Matthew@example.com', 'Name of recipient');\n$mail- setSubject('TestSubject');\n\n$transport = new Mail\\Transport\\Sendmail();\n$transport- send($mail);", 
            "title": "Basic email"
        }, 
        {
            "location": "/intro/#minimum-definitions", 
            "text": "In order to send an email using zend-mail you have to specify at least one\nrecipient as well as a message body. Please note that each transport may\nrequire additional parameters to be set.   For most mail attributes there are \"get\" methods to read the information stored\nin the message object. for further details, please refer to the API\ndocumentation.", 
            "title": "Minimum definitions"
        }, 
        {
            "location": "/intro/#configuring-the-default-sendmail-transport", 
            "text": "The default transport is  Zend\\Mail\\Transport\\Sendmail . It is a wrapper to the\nPHP  mail()  function. If you wish to pass additional\nparameters to the  mail()  function, create a new transport\ninstance and pass your parameters to the constructor.", 
            "title": "Configuring the default sendmail transport"
        }, 
        {
            "location": "/intro/#passing-additional-mail-parameters", 
            "text": "This example shows how to change the Return-Path of the mail()  function.  use Zend\\Mail;\n\n$mail = new Mail\\Message();\n$mail- setBody('This is the text of the email.');\n$mail- setFrom('Freeaqingme@example.org', 'Dolf');\n$mail- addTo('matthew@example.com', 'Matthew');\n$mail- setSubject('TestSubject');\n\n$transport = new Mail\\Transport\\Sendmail('-freturn_to_me@example.com');\n$transport- send($mail);", 
            "title": "Passing additional mail() parameters"
        }, 
        {
            "location": "/intro/#chose-your-transport-wisely", 
            "text": "Although the sendmail transport is the transport that requires least\nconfiguration, it may not be suitable for your production environment. This is\nbecause emails sent using the sendmail transport will be more often delivered\nto SPAM-boxes. This can partly be remedied by using the SMTP Transport  combined with an SMTP\nserver that has an overall good reputation. Additionally, techniques such as\nSPF and DKIM may be employed to ensure even more email messages are delivered\nsuccessfully.", 
            "title": "Chose your transport wisely"
        }, 
        {
            "location": "/intro/#warning-sendmail-transport-and-windows", 
            "text": "As the PHP manual states, the  mail()  function has different behaviour on\nWindows than it does on *nix based systems. Using the sendmail transport on\nWindows will not work in combination with  addBcc() .  The  mail()  function\nwill send to the BCC recipient such that all the other recipients can see that\naddress as the recipient!  Therefore if you want to use BCC on a windows server, use the SMTP transport\nfor sending!", 
            "title": "Warning: Sendmail Transport and Windows"
        }, 
        {
            "location": "/message/intro/", 
            "text": "Messages\n\n\nZend\\Mail\\Message\n encapsulates a single email message as described in RFCs\n\n822\n and\n\n2822\n. It acts as a value object for\nsetting mail headers and content.\n\n\nIf desired, multi-part email messages may also be created. This can be done\nusing the \nzend-mime\n component,\nand assigning the generated MIME part to the mail message body.\n\n\nThe \nMessage\n class is a value object. It is not capable of sending or storing itself; for\nthose purposes, you will need to use, respectively, a \nTransport adapter\n or\na \nStorage adapter\n.\n\n\nQuick Start\n\n\nCreating a \nMessage\n by instantiating it:\n\n\nuse Zend\\Mail\\Message;\n\n$message = new Message();\n\n\n\n\nOnce you have your \nMessage\n instance, you can start adding content or headers.\nLet's set who the mail is from, who it's addressed to, a subject, and some\ncontent:\n\n\n$message-\naddFrom('matthew@example.org', 'Matthew Somelli');\n$message-\naddTo('foobar@example.com');\n$message-\nsetSubject('Sending an email from Zend\\Mail!');\n$message-\nsetBody('This is the message body.');\n\n\n\n\nYou can also add recipients to carbon-copy (\"Cc:\") or blind carbon-copy\n(\"Bcc:\").\n\n\n$message-\naddCc('ralph@example.org');\n$message-\naddBcc('enrico@example.org');\n\n\n\n\nIf you want to specify an alternate address to which replies may be sent, that\ncan be done, too.\n\n\n$message-\naddReplyTo('matthew@example.com', 'Matthew');\n\n\n\n\nInterestingly, RFC-822 allows for multiple \"From:\" addresses. When you do this,\nthe first one will be used as the sender, \nunless\n you specify a \"Sender:\"\nheader. The \nMessage\n class allows for this.\n\n\n/*\n * Mail headers created:\n * From: Ralph Nader \nralph@example.org\n, Enrico Volante \nenrico@example.org\n\n * Sender: Matthew Sommeli \nmatthew@example.org\n\n */\n$message-\naddFrom('ralph@example.org', 'Ralph Nader');\n$message-\naddFrom('enrico@example.org', 'Enrico Volante');\n$message-\nsetSender('matthew@example.org', 'Matthew Sommeli');\n\n\n\n\nBy default, the \nMessage\n class assumes ASCII encoding for your email. If you\nwish to use another encoding, you can do so; setting this will ensure all\nheaders and body content are properly encoded using quoted-printable encoding.\n\n\n$message-\nsetEncoding('UTF-8');\n\n\n\n\nIf you wish to set other headers, you can do that as well.\n\n\n/*\n * Mail headers created:\n * X-API-Key: FOO-BAR-BAZ-BAT\n */\n$message-\ngetHeaders()-\naddHeaderLine('X-API-Key', 'FOO-BAR-BAZ-BAT');\n\n\n\n\nSometimes you may want to provide HTML content, or multi-part content. To do\nthat, you'll first create a MIME message object, and then set it as the body of\nyour mail message object. When you do so, the \nMessage\n class will automatically\nset a \"MIME-Version\" header, as well as an appropriate \"Content-Type\" header.\n\n\nIf you are interested in multipart emails or using attachments, read the chapter\non \nAdding Attachments\n.\n\n\nIf you want a string representation of your email, you can get that:\n\n\necho $message-\ntoString();\n\n\n\n\nFinally, you can fully introspect the message, including getting all addresses\nof recipients and senders, all headers, and the message body.\n\n\n// Headers\n// Note: this will also grab all headers for which accessors/mutators exist in\n// the Message object itself.\nforeach ($message-\ngetHeaders() as $header) {\n    echo $header-\ntoString();\n    // or grab values: $header-\ngetFieldName(), $header-\ngetFieldValue()\n}\n\n// The logic below also works for the methods cc(), bcc(), to(), and replyTo()\nforeach ($message-\ngetFrom() as $address) {\n    printf(\n%s: %s\\n\n, $address-\ngetEmail(), $address-\ngetName());\n}\n\n// Sender\n$address = $message-\ngetSender();\nif (! is_null($address)) {\n   printf(\n%s: %s\\n\n, $address-\ngetEmail(), $address-\ngetName());\n}\n\n// Subject\necho \nSubject: \n, $message-\ngetSubject(), \n\\n\n;\n\n// Encoding\necho \nEncoding: \n, $message-\ngetEncoding(), \n\\n\n;\n\n// Message body:\necho $message-\ngetBody();     // raw body, or MIME object\necho $message-\ngetBodyText(); // body as it will be sent\n\n\n\n\nOnce your message is shaped to your liking, pass it to a\n\nmail transport\n in order to send it!\n\n\n$transport-\nsend($message);\n\n\n\n\nConfiguration Options\n\n\nThe \nMessage\n class has no configuration options, and is instead a value object.\n\n\nAvailable Methods\n\n\nisValid\n\n\nisValid() : bool\n\n\n\n\nMessages without a \nFrom\n address are invalid, per RFC-2822.\n\n\nsetEncoding\n\n\nsetEncoding(string $encoding) : void\n\n\n\n\nSet the message encoding.\n\n\ngetEncoding\n\n\ngetEncoding() : string\n\n\n\n\nGet the message encoding.\n\n\nsetHeaders\n\n\nsetHeaders(Zend\\Mail\\Headers $headers) : void\n\n\n\n\nCompose headers.\n\n\ngetHeaders\n\n\ngetHeaders() : Zend\\Mail\\Headers\n\n\n\n\nAccess headers collection, lazy-loading a \nHeaders\n instance if none was\npreviously attached.\n\n\nsetFrom\n\n\nsetFrom(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void\n\n\n\n\nSet (overwrite) \nFrom\n addresses. If an associative array is provided, it must\nbe a set of key/value pairs where the key is the human readable name, and the\nvalue is the email address.\n\n\naddFrom\n\n\naddFrom(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressOrList,\n    string|null $name\n) : void\n\n\n\n\nAdd a \nFrom\n address. If an associative array is provided, it must be a set of\nkey/value pairs where the key is the human readable name, and the value is the\nemail address.\n\n\ngetFrom\n\n\ngetFrom() : AddressList\n\n\n\n\nRetrieve list of \nFrom\n senders.\n\n\nsetTo\n\n\nsetTo(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    null|string $name\n) : void\n\n\n\n\nOverwrite the address list in the \nTo\n recipients. If an associative array is\nprovided, it must be a set of key/value pairs where the key is the human\nreadable name, and the value is the email address.\n\n\naddTo\n\n\naddTo(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressOrList,\n    null|string $name\n) : void\n\n\n\n\nAdd one or more addresses to the \nTo\n recipients; appends to the list. If an\nassociative array is provided, it must be a set of key/value pairs where the key\nis the human readable name, and the value is the email address.\n\n\ngetTo\n\n\ngetTo() : AddressList\n\n\n\n\nAccess the address list of the \nTo\n header.  Lazy-loads an \nAddressList\n and\npopulates the \nTo\n header if not previously done.\n\n\nsetCc\n\n\nsetCc(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void\n\n\n\n\nSet (overwrite) \nCc\n addresses. If an associative array is provided, it must be\na set of key/value pairs where the key is the human readable name, and the value\nis the email address.\n\n\naddCc\n\n\naddCc(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void\n\n\n\n\nAdd a \nCc\n address. If an associative array is provided, it must be a set of\nkey/value pairs where the key is the human readable name, and the value is the\nemail address.\n\n\ngetCc\n\n\ngetCc() : AddressList\n\n\n\n\nRetrieve list of \nCc\n recipients.  Lazy-loads an \nAddressList\n and populates the\n\nCc\n header if not previously done.\n\n\nsetBcc\n\n\nsetBcc(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void\n\n\n\n\nSet (overwrite) \nBcc\n addresses. If an associative array is provided, it must be\na set of key/value pairs where the key is the human readable name, and the value\nis the email address.\n\n\naddBcc\n\n\naddBcc(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void\n\n\n\n\nAdd a \nBcc\n address. If an associative array is provided, it must be a set of\nkey/value pairs where the key is the human readable name, and the value is the\nemail address.\n\n\ngetBcc\n\n\ngetBcc() : AddressList\n\n\n\n\nRetrieve list of \nBcc\n recipients.  Lazy-loads an \nAddressList\n and populates\nthe \nBcc\n header if not previously done.\n\n\nsetReplyTo\n\n\nsetReplyTo(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void\n\n\n\n\nOverwrite the address list in the \nReply-To\n recipients. If an associative array\nis provided, it must be a set of key/value pairs where the key is the human\nreadable name, and the value is the email address.\n\n\naddReplyTo\n\n\naddReplyTo(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void\n\n\n\n\nAdd one or more addresses to the \nReply-To\n recipients. If an associative array\nis provided, it must be a set of key/value pairs where the key is the human\nreadable name, and the value is the email address.\n\n\ngetReplyTo\n\n\ngetReplyTo() : AddressList\n\n\n\n\nAccess the address list of the \nReply-To\n header.  Lazy-loads an \nAddressList\n\nand populates the \nReply-To\n header if not previously done.\n\n\nsetSender\n\n\nsetSender(\n    string|AddressInterface $emailOrAddress,\n    null|string $name\n) : void\n\n\n\n\nSet the message envelope \nSender\n header.\n\n\ngetSender\n\n\ngetSender() : null|AddressInterface\n\n\n\n\nRetrieve the sender address, if any.\n\n\nsetSubject\n\n\nsetSubject(string $subject) :void\n\n\n\n\nSet the message subject header value.\n\n\ngetSubject\n\n\ngetSubject() : null|string\n\n\n\n\nGet the message subject header value.\n\n\nsetBody\n\n\nsetBody(null|string|Zend\\Mime\\Message|object $body) : void\n\n\n\n\nSet the message body. If a generic object is provided, it must implement\n\n__toString()\n.\n\n\ngetBody\n\n\ngetBody() : null|string|object\n\n\n\n\nReturn the currently set message body. Object return values include\n\nZend\\Mime\\Message\n instances or objects implementing \n__toString()\n.\n\n\ngetBodyText\n\n\ngetBodyText() : null|string\n\n\n\n\nGet the string-serialized message body text.\n\n\ntoString\n\n\ntoString() : string\n\n\n\n\nSerialize to string.", 
            "title": "Intro and Usage"
        }, 
        {
            "location": "/message/intro/#messages", 
            "text": "Zend\\Mail\\Message  encapsulates a single email message as described in RFCs 822  and 2822 . It acts as a value object for\nsetting mail headers and content.  If desired, multi-part email messages may also be created. This can be done\nusing the  zend-mime  component,\nand assigning the generated MIME part to the mail message body.  The  Message  class is a value object. It is not capable of sending or storing itself; for\nthose purposes, you will need to use, respectively, a  Transport adapter  or\na  Storage adapter .", 
            "title": "Messages"
        }, 
        {
            "location": "/message/intro/#quick-start", 
            "text": "Creating a  Message  by instantiating it:  use Zend\\Mail\\Message;\n\n$message = new Message();  Once you have your  Message  instance, you can start adding content or headers.\nLet's set who the mail is from, who it's addressed to, a subject, and some\ncontent:  $message- addFrom('matthew@example.org', 'Matthew Somelli');\n$message- addTo('foobar@example.com');\n$message- setSubject('Sending an email from Zend\\Mail!');\n$message- setBody('This is the message body.');  You can also add recipients to carbon-copy (\"Cc:\") or blind carbon-copy\n(\"Bcc:\").  $message- addCc('ralph@example.org');\n$message- addBcc('enrico@example.org');  If you want to specify an alternate address to which replies may be sent, that\ncan be done, too.  $message- addReplyTo('matthew@example.com', 'Matthew');  Interestingly, RFC-822 allows for multiple \"From:\" addresses. When you do this,\nthe first one will be used as the sender,  unless  you specify a \"Sender:\"\nheader. The  Message  class allows for this.  /*\n * Mail headers created:\n * From: Ralph Nader  ralph@example.org , Enrico Volante  enrico@example.org \n * Sender: Matthew Sommeli  matthew@example.org \n */\n$message- addFrom('ralph@example.org', 'Ralph Nader');\n$message- addFrom('enrico@example.org', 'Enrico Volante');\n$message- setSender('matthew@example.org', 'Matthew Sommeli');  By default, the  Message  class assumes ASCII encoding for your email. If you\nwish to use another encoding, you can do so; setting this will ensure all\nheaders and body content are properly encoded using quoted-printable encoding.  $message- setEncoding('UTF-8');  If you wish to set other headers, you can do that as well.  /*\n * Mail headers created:\n * X-API-Key: FOO-BAR-BAZ-BAT\n */\n$message- getHeaders()- addHeaderLine('X-API-Key', 'FOO-BAR-BAZ-BAT');  Sometimes you may want to provide HTML content, or multi-part content. To do\nthat, you'll first create a MIME message object, and then set it as the body of\nyour mail message object. When you do so, the  Message  class will automatically\nset a \"MIME-Version\" header, as well as an appropriate \"Content-Type\" header.  If you are interested in multipart emails or using attachments, read the chapter\non  Adding Attachments .  If you want a string representation of your email, you can get that:  echo $message- toString();  Finally, you can fully introspect the message, including getting all addresses\nof recipients and senders, all headers, and the message body.  // Headers\n// Note: this will also grab all headers for which accessors/mutators exist in\n// the Message object itself.\nforeach ($message- getHeaders() as $header) {\n    echo $header- toString();\n    // or grab values: $header- getFieldName(), $header- getFieldValue()\n}\n\n// The logic below also works for the methods cc(), bcc(), to(), and replyTo()\nforeach ($message- getFrom() as $address) {\n    printf( %s: %s\\n , $address- getEmail(), $address- getName());\n}\n\n// Sender\n$address = $message- getSender();\nif (! is_null($address)) {\n   printf( %s: %s\\n , $address- getEmail(), $address- getName());\n}\n\n// Subject\necho  Subject:  , $message- getSubject(),  \\n ;\n\n// Encoding\necho  Encoding:  , $message- getEncoding(),  \\n ;\n\n// Message body:\necho $message- getBody();     // raw body, or MIME object\necho $message- getBodyText(); // body as it will be sent  Once your message is shaped to your liking, pass it to a mail transport  in order to send it!  $transport- send($message);", 
            "title": "Quick Start"
        }, 
        {
            "location": "/message/intro/#configuration-options", 
            "text": "The  Message  class has no configuration options, and is instead a value object.", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/message/intro/#available-methods", 
            "text": "", 
            "title": "Available Methods"
        }, 
        {
            "location": "/message/intro/#isvalid", 
            "text": "isValid() : bool  Messages without a  From  address are invalid, per RFC-2822.", 
            "title": "isValid"
        }, 
        {
            "location": "/message/intro/#setencoding", 
            "text": "setEncoding(string $encoding) : void  Set the message encoding.", 
            "title": "setEncoding"
        }, 
        {
            "location": "/message/intro/#getencoding", 
            "text": "getEncoding() : string  Get the message encoding.", 
            "title": "getEncoding"
        }, 
        {
            "location": "/message/intro/#setheaders", 
            "text": "setHeaders(Zend\\Mail\\Headers $headers) : void  Compose headers.", 
            "title": "setHeaders"
        }, 
        {
            "location": "/message/intro/#getheaders", 
            "text": "getHeaders() : Zend\\Mail\\Headers  Access headers collection, lazy-loading a  Headers  instance if none was\npreviously attached.", 
            "title": "getHeaders"
        }, 
        {
            "location": "/message/intro/#setfrom", 
            "text": "setFrom(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void  Set (overwrite)  From  addresses. If an associative array is provided, it must\nbe a set of key/value pairs where the key is the human readable name, and the\nvalue is the email address.", 
            "title": "setFrom"
        }, 
        {
            "location": "/message/intro/#addfrom", 
            "text": "addFrom(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressOrList,\n    string|null $name\n) : void  Add a  From  address. If an associative array is provided, it must be a set of\nkey/value pairs where the key is the human readable name, and the value is the\nemail address.", 
            "title": "addFrom"
        }, 
        {
            "location": "/message/intro/#getfrom", 
            "text": "getFrom() : AddressList  Retrieve list of  From  senders.", 
            "title": "getFrom"
        }, 
        {
            "location": "/message/intro/#setto", 
            "text": "setTo(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    null|string $name\n) : void  Overwrite the address list in the  To  recipients. If an associative array is\nprovided, it must be a set of key/value pairs where the key is the human\nreadable name, and the value is the email address.", 
            "title": "setTo"
        }, 
        {
            "location": "/message/intro/#addto", 
            "text": "addTo(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressOrList,\n    null|string $name\n) : void  Add one or more addresses to the  To  recipients; appends to the list. If an\nassociative array is provided, it must be a set of key/value pairs where the key\nis the human readable name, and the value is the email address.", 
            "title": "addTo"
        }, 
        {
            "location": "/message/intro/#getto", 
            "text": "getTo() : AddressList  Access the address list of the  To  header.  Lazy-loads an  AddressList  and\npopulates the  To  header if not previously done.", 
            "title": "getTo"
        }, 
        {
            "location": "/message/intro/#setcc", 
            "text": "setCc(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void  Set (overwrite)  Cc  addresses. If an associative array is provided, it must be\na set of key/value pairs where the key is the human readable name, and the value\nis the email address.", 
            "title": "setCc"
        }, 
        {
            "location": "/message/intro/#addcc", 
            "text": "addCc(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void  Add a  Cc  address. If an associative array is provided, it must be a set of\nkey/value pairs where the key is the human readable name, and the value is the\nemail address.", 
            "title": "addCc"
        }, 
        {
            "location": "/message/intro/#getcc", 
            "text": "getCc() : AddressList  Retrieve list of  Cc  recipients.  Lazy-loads an  AddressList  and populates the Cc  header if not previously done.", 
            "title": "getCc"
        }, 
        {
            "location": "/message/intro/#setbcc", 
            "text": "setBcc(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void  Set (overwrite)  Bcc  addresses. If an associative array is provided, it must be\na set of key/value pairs where the key is the human readable name, and the value\nis the email address.", 
            "title": "setBcc"
        }, 
        {
            "location": "/message/intro/#addbcc", 
            "text": "addBcc(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void  Add a  Bcc  address. If an associative array is provided, it must be a set of\nkey/value pairs where the key is the human readable name, and the value is the\nemail address.", 
            "title": "addBcc"
        }, 
        {
            "location": "/message/intro/#getbcc", 
            "text": "getBcc() : AddressList  Retrieve list of  Bcc  recipients.  Lazy-loads an  AddressList  and populates\nthe  Bcc  header if not previously done.", 
            "title": "getBcc"
        }, 
        {
            "location": "/message/intro/#setreplyto", 
            "text": "setReplyTo(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void  Overwrite the address list in the  Reply-To  recipients. If an associative array\nis provided, it must be a set of key/value pairs where the key is the human\nreadable name, and the value is the email address.", 
            "title": "setReplyTo"
        }, 
        {
            "location": "/message/intro/#addreplyto", 
            "text": "addReplyTo(\n    string|AddressInterface|array|AddressList|Traversable $emailOrAddressList,\n    string|null $name\n) : void  Add one or more addresses to the  Reply-To  recipients. If an associative array\nis provided, it must be a set of key/value pairs where the key is the human\nreadable name, and the value is the email address.", 
            "title": "addReplyTo"
        }, 
        {
            "location": "/message/intro/#getreplyto", 
            "text": "getReplyTo() : AddressList  Access the address list of the  Reply-To  header.  Lazy-loads an  AddressList \nand populates the  Reply-To  header if not previously done.", 
            "title": "getReplyTo"
        }, 
        {
            "location": "/message/intro/#setsender", 
            "text": "setSender(\n    string|AddressInterface $emailOrAddress,\n    null|string $name\n) : void  Set the message envelope  Sender  header.", 
            "title": "setSender"
        }, 
        {
            "location": "/message/intro/#getsender", 
            "text": "getSender() : null|AddressInterface  Retrieve the sender address, if any.", 
            "title": "getSender"
        }, 
        {
            "location": "/message/intro/#setsubject", 
            "text": "setSubject(string $subject) :void  Set the message subject header value.", 
            "title": "setSubject"
        }, 
        {
            "location": "/message/intro/#getsubject", 
            "text": "getSubject() : null|string  Get the message subject header value.", 
            "title": "getSubject"
        }, 
        {
            "location": "/message/intro/#setbody", 
            "text": "setBody(null|string|Zend\\Mime\\Message|object $body) : void  Set the message body. If a generic object is provided, it must implement __toString() .", 
            "title": "setBody"
        }, 
        {
            "location": "/message/intro/#getbody", 
            "text": "getBody() : null|string|object  Return the currently set message body. Object return values include Zend\\Mime\\Message  instances or objects implementing  __toString() .", 
            "title": "getBody"
        }, 
        {
            "location": "/message/intro/#getbodytext", 
            "text": "getBodyText() : null|string  Get the string-serialized message body text.", 
            "title": "getBodyText"
        }, 
        {
            "location": "/message/intro/#tostring", 
            "text": "toString() : string  Serialize to string.", 
            "title": "toString"
        }, 
        {
            "location": "/message/attachments/", 
            "text": "Adding Attachments\n\n\nzend-mail does not directly provide the ability to create and use mail\nattachments. However, it allows using \nZend\\Mime\\Message\n instances, from the\n\nzend-mime\n component, for message\nbodies, allowing you to create multipart emails.\n\n\nBasic multipart content\n\n\nThe following example creates an email with two parts, HTML content and an\nimage.\n\n\nuse Zend\\Mail\\Message;\nuse Zend\\Mime\\Message as MimeMessage;\nuse Zend\\Mime\\Mime;\nuse Zend\\Mime\\Part as MimePart;\n\n$html = new MimePart($htmlMarkup);\n$html-\ntype = Mime::TYPE_HTML;\n$html-\ncharset = 'utf-8';\n$html-\nencoding = Mime::ENCODING_QUOTEDPRINTABLE;\n\n$image = new MimePart(fopen($pathToImage, 'r'));\n$image-\ntype = 'image/jpeg';\n$image-\nfilename = 'image-file-name.jpg';\n$image-\ndisposition = Mime::DISPOSITION_ATTACHMENT;\n$image-\nencoding = Mime::ENCODING_BASE64;\n\n$body = new MimeMessage();\n$body-\nsetParts([$html, $image]);\n\n$message = new Message();\n$message-\nsetBody($body);\n$message-\ngetHeaders()-\naddHeaderLine('Content-Type', 'multipart/related');\n\n\n\n\nNote that the above code requires us to manually specify the message content\ntype; zend-mime does not automatically select the multipart type for us, nor\ndoes zend-mail populate it by default.\n\n\nmultipart/alternative content\n\n\nOne of the most common email types sent by web applications is\n\nmultipart/alternative\n messages with both text and HTML parts.\n\n\nuse Zend\\Mail\\Message;\nuse Zend\\Mime\\Message as MimeMessage;\nuse Zend\\Mime\\Mime;\nuse Zend\\Mime\\Part as MimePart;\n\n$text = new MimePart($textContent);\n$text-\ntype = Mime::TYPE_TEXT;\n$text-\ncharset = 'utf-8';\n$text-\nencoding = Mime::ENCODING_QUOTEDPRINTABLE;\n\n$html = new MimePart($htmlMarkup);\n$html-\ntype = Mime::TYPE_HTML;\n$html-\ncharset = 'utf-8';\n$html-\nencoding = Mime::ENCODING_QUOTEDPRINTABLE;\n\n$body = new MimeMessage();\n$body-\nsetParts([$text, $html]);\n\n$message = new Message();\n$message-\nsetBody($body);\n$message-\ngetHeaders()-\naddHeaderLine('Content-Type', 'multipart/alternative');\n\n\n\n\nThe only differences from the first example are:\n\n\n\n\nWe have text and HTML parts instead of an HTML and image part.\n\n\nThe \nContent-Type\n header is now \nmultipart/alternative\n.\n\n\n\n\nmultipart/alternative emails with attachments\n\n\nAnother common task is creating \nmultipart/alternative\n emails where the HTML\ncontent refers to assets attachments (images, CSS, etc.).\n\n\nTo accomplish this, we need to:\n\n\n\n\nCreate a \nZend\\Mime\\Part\n instance containing our \nmultipart/alternative\n\n  message.\n\n\nAdd that part to a \nZend\\Mime\\Message\n.\n\n\nAdd additional \nZend\\Mime\\Part\n instances to the MIME message.\n\n\nAttach the MIME message as the \nZend\\Mail\\Message\n content body.\n\n\nMark the message as \nmultipart/related\n content.\n\n\n\n\nThe following example creates a MIME message with three parts: text and HTML\nalternative versions of an email, and an image attachment.\n\n\nuse Zend\\Mail\\Message;\nuse Zend\\Mime\\Message as MimeMessage;\nuse Zend\\Mime\\Mime;\nuse Zend\\Mime\\Part as MimePart;\n\n$body = new MimeMessage();\n\n$text = new MimePart($textContent);\n$text-\ntype = Mime::TYPE_TEXT;\n$text-\ncharset = 'utf-8';\n$text-\nencoding = Mime::ENCODING_QUOTEDPRINTABLE;\n\n$html = new MimePart($htmlMarkup);\n$html-\ntype = Mime::TYPE_HTML;\n$html-\ncharset = 'utf-8';\n$html-\nencoding = Mime::ENCODING_QUOTEDPRINTABLE;\n\n$content = new MimeMessage();\n$content-\nsetParts([$text, $html]);\n\n$contentPart = new MimePart($content-\ngenerateMessage());\n$contentPart-\ntype = sprintf(\n    \nmultipart/alternative\\n boundary=\\\n%s\\\n,\n    $content-\ngetMime()-\nboundary()\n);\n\n$image = new MimePart(fopen($pathToImage, 'r'));\n$image-\ntype = 'image/jpeg';\n$image-\nfilename = 'image-file-name.jpg';\n$image-\ndisposition = Mime::DISPOSITION_ATTACHMENT;\n$image-\nencoding = Mime::ENCODING_BASE64;\n\n$body = new MimeMessage();\n$body-\nsetParts([$contentPart, $image]);\n\n$message = new Message();\n$message-\nsetBody($body);\n$message-\ngeHeaders()-\naddHeaderLine('Content-Type', 'multipart/related');\n\n\n\n\nSetting custom MIME boundaries\n\n\nIn a multipart message, a MIME boundary for separating the different parts of\nthe message is normally generated at random. In some cases, however, you might\nwant to specify the MIME boundary that is used. This can be done by injecting a\nnew \nZend\\Mime\\Mime\n instance into the MIME message.\n\n\nuse Zend\\Mime\\Mime;\n\n$mimeMessage-\nsetMime(new Mime($customBoundary));", 
            "title": "Attachments"
        }, 
        {
            "location": "/message/attachments/#adding-attachments", 
            "text": "zend-mail does not directly provide the ability to create and use mail\nattachments. However, it allows using  Zend\\Mime\\Message  instances, from the zend-mime  component, for message\nbodies, allowing you to create multipart emails.", 
            "title": "Adding Attachments"
        }, 
        {
            "location": "/message/attachments/#basic-multipart-content", 
            "text": "The following example creates an email with two parts, HTML content and an\nimage.  use Zend\\Mail\\Message;\nuse Zend\\Mime\\Message as MimeMessage;\nuse Zend\\Mime\\Mime;\nuse Zend\\Mime\\Part as MimePart;\n\n$html = new MimePart($htmlMarkup);\n$html- type = Mime::TYPE_HTML;\n$html- charset = 'utf-8';\n$html- encoding = Mime::ENCODING_QUOTEDPRINTABLE;\n\n$image = new MimePart(fopen($pathToImage, 'r'));\n$image- type = 'image/jpeg';\n$image- filename = 'image-file-name.jpg';\n$image- disposition = Mime::DISPOSITION_ATTACHMENT;\n$image- encoding = Mime::ENCODING_BASE64;\n\n$body = new MimeMessage();\n$body- setParts([$html, $image]);\n\n$message = new Message();\n$message- setBody($body);\n$message- getHeaders()- addHeaderLine('Content-Type', 'multipart/related');  Note that the above code requires us to manually specify the message content\ntype; zend-mime does not automatically select the multipart type for us, nor\ndoes zend-mail populate it by default.", 
            "title": "Basic multipart content"
        }, 
        {
            "location": "/message/attachments/#multipartalternative-content", 
            "text": "One of the most common email types sent by web applications is multipart/alternative  messages with both text and HTML parts.  use Zend\\Mail\\Message;\nuse Zend\\Mime\\Message as MimeMessage;\nuse Zend\\Mime\\Mime;\nuse Zend\\Mime\\Part as MimePart;\n\n$text = new MimePart($textContent);\n$text- type = Mime::TYPE_TEXT;\n$text- charset = 'utf-8';\n$text- encoding = Mime::ENCODING_QUOTEDPRINTABLE;\n\n$html = new MimePart($htmlMarkup);\n$html- type = Mime::TYPE_HTML;\n$html- charset = 'utf-8';\n$html- encoding = Mime::ENCODING_QUOTEDPRINTABLE;\n\n$body = new MimeMessage();\n$body- setParts([$text, $html]);\n\n$message = new Message();\n$message- setBody($body);\n$message- getHeaders()- addHeaderLine('Content-Type', 'multipart/alternative');  The only differences from the first example are:   We have text and HTML parts instead of an HTML and image part.  The  Content-Type  header is now  multipart/alternative .", 
            "title": "multipart/alternative content"
        }, 
        {
            "location": "/message/attachments/#multipartalternative-emails-with-attachments", 
            "text": "Another common task is creating  multipart/alternative  emails where the HTML\ncontent refers to assets attachments (images, CSS, etc.).  To accomplish this, we need to:   Create a  Zend\\Mime\\Part  instance containing our  multipart/alternative \n  message.  Add that part to a  Zend\\Mime\\Message .  Add additional  Zend\\Mime\\Part  instances to the MIME message.  Attach the MIME message as the  Zend\\Mail\\Message  content body.  Mark the message as  multipart/related  content.   The following example creates a MIME message with three parts: text and HTML\nalternative versions of an email, and an image attachment.  use Zend\\Mail\\Message;\nuse Zend\\Mime\\Message as MimeMessage;\nuse Zend\\Mime\\Mime;\nuse Zend\\Mime\\Part as MimePart;\n\n$body = new MimeMessage();\n\n$text = new MimePart($textContent);\n$text- type = Mime::TYPE_TEXT;\n$text- charset = 'utf-8';\n$text- encoding = Mime::ENCODING_QUOTEDPRINTABLE;\n\n$html = new MimePart($htmlMarkup);\n$html- type = Mime::TYPE_HTML;\n$html- charset = 'utf-8';\n$html- encoding = Mime::ENCODING_QUOTEDPRINTABLE;\n\n$content = new MimeMessage();\n$content- setParts([$text, $html]);\n\n$contentPart = new MimePart($content- generateMessage());\n$contentPart- type = sprintf(\n     multipart/alternative\\n boundary=\\ %s\\ ,\n    $content- getMime()- boundary()\n);\n\n$image = new MimePart(fopen($pathToImage, 'r'));\n$image- type = 'image/jpeg';\n$image- filename = 'image-file-name.jpg';\n$image- disposition = Mime::DISPOSITION_ATTACHMENT;\n$image- encoding = Mime::ENCODING_BASE64;\n\n$body = new MimeMessage();\n$body- setParts([$contentPart, $image]);\n\n$message = new Message();\n$message- setBody($body);\n$message- geHeaders()- addHeaderLine('Content-Type', 'multipart/related');", 
            "title": "multipart/alternative emails with attachments"
        }, 
        {
            "location": "/message/attachments/#setting-custom-mime-boundaries", 
            "text": "In a multipart message, a MIME boundary for separating the different parts of\nthe message is normally generated at random. In some cases, however, you might\nwant to specify the MIME boundary that is used. This can be done by injecting a\nnew  Zend\\Mime\\Mime  instance into the MIME message.  use Zend\\Mime\\Mime;\n\n$mimeMessage- setMime(new Mime($customBoundary));", 
            "title": "Setting custom MIME boundaries"
        }, 
        {
            "location": "/message/character-sets/", 
            "text": "Character Sets\n\n\nZend\\Mail\\Message\n assumes a default ASCII character set, and headers and\ncontent are quoted accordingly. If you wish to specify alternate characters\nsets, you will need to:\n\n\n\n\nNotify the \nMessage\n instance of the desired character-set encoding, to ensure\n  headers are encoded correctly.\n\n\nSet an appropriate \nContent-Type\n header.\n\n\nIn multipart messages, set the character set per-part.\n\n\n\n\n\n\nOnly in text format\n\n\nCharacter sets are only applicable for message parts in text format.\n\n\n\n\nExample\n\n\nThe following example is how to use \nZend\\Mail\\Message\n to send a message in\nJapanese.\n\n\nuse Zend\\Mail\\Message;\nuse Zend\\Mime\\Message as MimeMessage;\nuse Zend\\Mime\\Mime;\nuse Zend\\Mime\\Part as MimePart;\n\n// Typically, PHP will use UTF-8 internally; the following converts\n// the text to a Japanese encoding.\nfunction convertToJapaneseEncoding($string) {\n    return mb_convert_encoding($string, 'ISO-2022-JP', 'UTF-8');\n}\n\n$mail = new Message();\n\n// Set message encoding; this only affects headers.\n$mail-\nsetEncoding('ISO-2022-JP');\n\n// Set the message content type:\n$mail-\ngetHeaders()-\naddHeaderLine('Content-Type', 'text/plain; charset=ISO-2022-JP');\n\n// Add some headers. Textual content needs to be encoded first.\n$mail-\nsetFrom('somebody@example.com', convertToJapaneseEncoding('Some Sender'));\n$mail-\naddTo('somebody_else@example.com', convertToJapaneseEncoding('Some Recipient'));\n$mail-\nsetSubject(convertToJapaneseEncoding('TestSubject'));\n\n// Create a MIME part specifying 7bit encoding:\n$part = new MimePart(convertToJapaneseEncoding($content));\n$part-\nencoding = Mime::ENCODING_7BIT;\n\n// Create a MIME message, add the part, and attach it to the mail message:\n$body = new MimeMessage();\n$body-\naddPart($part);\n$mail-\nsetBody($body);", 
            "title": "Character Sets"
        }, 
        {
            "location": "/message/character-sets/#character-sets", 
            "text": "Zend\\Mail\\Message  assumes a default ASCII character set, and headers and\ncontent are quoted accordingly. If you wish to specify alternate characters\nsets, you will need to:   Notify the  Message  instance of the desired character-set encoding, to ensure\n  headers are encoded correctly.  Set an appropriate  Content-Type  header.  In multipart messages, set the character set per-part.", 
            "title": "Character Sets"
        }, 
        {
            "location": "/message/character-sets/#only-in-text-format", 
            "text": "Character sets are only applicable for message parts in text format.", 
            "title": "Only in text format"
        }, 
        {
            "location": "/message/character-sets/#example", 
            "text": "The following example is how to use  Zend\\Mail\\Message  to send a message in\nJapanese.  use Zend\\Mail\\Message;\nuse Zend\\Mime\\Message as MimeMessage;\nuse Zend\\Mime\\Mime;\nuse Zend\\Mime\\Part as MimePart;\n\n// Typically, PHP will use UTF-8 internally; the following converts\n// the text to a Japanese encoding.\nfunction convertToJapaneseEncoding($string) {\n    return mb_convert_encoding($string, 'ISO-2022-JP', 'UTF-8');\n}\n\n$mail = new Message();\n\n// Set message encoding; this only affects headers.\n$mail- setEncoding('ISO-2022-JP');\n\n// Set the message content type:\n$mail- getHeaders()- addHeaderLine('Content-Type', 'text/plain; charset=ISO-2022-JP');\n\n// Add some headers. Textual content needs to be encoded first.\n$mail- setFrom('somebody@example.com', convertToJapaneseEncoding('Some Sender'));\n$mail- addTo('somebody_else@example.com', convertToJapaneseEncoding('Some Recipient'));\n$mail- setSubject(convertToJapaneseEncoding('TestSubject'));\n\n// Create a MIME part specifying 7bit encoding:\n$part = new MimePart(convertToJapaneseEncoding($content));\n$part- encoding = Mime::ENCODING_7BIT;\n\n// Create a MIME message, add the part, and attach it to the mail message:\n$body = new MimeMessage();\n$body- addPart($part);\n$mail- setBody($body);", 
            "title": "Example"
        }, 
        {
            "location": "/transport/intro/", 
            "text": "Transports\n\n\nTransports take care of the actual delivery of mail. Typically, you only need to\nworry about two possibilities: using PHP's native \nmail()\n functionality, which\nuses system resources to deliver mail, or using the SMTP protocol for delivering\nmail via a remote server. Zend Framework also includes a \"File\" transport, which\ncreates a mail file for each message sent; these can later be introspected as\nlogs or consumed for the purposes of sending via an alternate transport\nmechanism later.\n\n\nThe \nZend\\Mail\\Transport\n interface defines exactly one method, \nsend()\n. This\nmethod accepts a \nZend\\Mail\\Message\n instance, which it then introspects and\nserializes in order to send.\n\n\nQuick Start\n\n\nUsing a mail transport involves instantiating it, optionally configuring it, and\nthen passing a message to it.\n\n\nSendmail Transport Usage\n\n\nuse Zend\\Mail\\Message;\nuse Zend\\Mail\\Transport\\Sendmail as SendmailTransport;\n\n$message = new Message();\n$message-\naddTo('matthew@example.org');\n$message-\naddFrom('ralph@example.org');\n$message-\nsetSubject('Greetings and Salutations!');\n$message-\nsetBody(\nSorry, I'm going to be late today!\n);\n\n$transport = new SendmailTransport();\n$transport-\nsend($message);\n\n\n\n\nSMTP Transport Usage\n\n\nuse Zend\\Mail\\Message;\nuse Zend\\Mail\\Transport\\Smtp as SmtpTransport;\nuse Zend\\Mail\\Transport\\SmtpOptions;\n\n$message = new Message();\n$message-\naddTo('matthew@example.org');\n$message-\naddFrom('ralph@example.org');\n$message-\nsetSubject('Greetings and Salutations!');\n$message-\nsetBody(\nSorry, I'm going to be late today!\n);\n\n// Setup SMTP transport using LOGIN authentication\n$transport = new SmtpTransport();\n$options   = new SmtpOptions([\n    'name'              =\n 'localhost.localdomain',\n    'host'              =\n '127.0.0.1',\n    'connection_class'  =\n 'login',\n    'connection_config' =\n [\n        'username' =\n 'user',\n        'password' =\n 'pass',\n    ],\n]);\n$transport-\nsetOptions($options);\n$transport-\nsend($message);\n\n\n\n\nFile Transport Usage\n\n\nuse Zend\\Mail\\Message;\nuse Zend\\Mail\\Transport\\File as FileTransport;\nuse Zend\\Mail\\Transport\\FileOptions;\nuse Zend\\Math\\Rand;\n\n$message = new Message();\n$message-\naddTo('matthew@example.org');\n$message-\naddFrom('ralph@example.org');\n$message-\nsetSubject('Greetings and Salutations!');\n$message-\nsetBody(\nSorry, I'm going to be late today!\n);\n\n// Setup File transport\n$transport = new FileTransport();\n$options   = new FileOptions([\n    'path'     =\n 'data/mail/',\n    'callback' =\n function (FileTransport $transport) {\n        return sprintf(\n            'Message_%f_%s.txt',\n            microtime(true),\n            Rand::getString(8)\n        );\n    },\n]);\n$transport-\nsetOptions($options);\n$transport-\nsend($message);\n\n\n\n\nInMemory Transport Usage\n\n\nuse Zend\\Mail\\Message;\nuse Zend\\Mail\\Transport\\InMemory as InMemoryTransport;\n\n$message = new Message();\n$message-\naddTo('matthew@example.org');\n$message-\naddFrom('ralph@example.org');\n$message-\nsetSubject('Greetings and Salutations!');\n$message-\nsetBody(\nSorry, I'm going to be late today!\n);\n\n// Setup InMemory transport\n$transport = new InMemoryTransport();\n$transport-\nsend($message);\n\n// Verify the message:\n$received = $transport-\ngetLastMessage();\n\n\n\n\nThe \nInMemory\n transport is primarily of interest when in development or when\ntesting.\n\n\nMigration from 2.0-2.3 to 2.4+\n\n\nVersion 2.4 adds support for PHP 7. In PHP 7, \nnull\n is a reserved keyword,\nwhich required renaming the \nNull\n transport. If you were using the \nNull\n\ntransport directly previously, you will now receive an \nE_USER_DEPRECATED\n\nnotice on instantiation. Please update your code to refer to the \nInMemory\n\nclass instead.\n\n\nUsers pulling their \nNull\n transport instance from the transport factory\n(\nZend\\Mail\\Transport\\Factory\n) receive an \nInMemory\n instance instead starting\nin 2.4.0.\n\n\nConfiguration Options\n\n\nConfiguration options are per transport. Please follow the links below for\ntransport-specific options.\n\n\n\n\nSMTP Transport Options\n\n\nFile Transport Options\n\n\n\n\nAvailable Methods\n\n\nsend\n\n\nsend(Zend\\Mail\\Message $message) : void\n\n\n\n\nSend a mail message.", 
            "title": "Usage"
        }, 
        {
            "location": "/transport/intro/#transports", 
            "text": "Transports take care of the actual delivery of mail. Typically, you only need to\nworry about two possibilities: using PHP's native  mail()  functionality, which\nuses system resources to deliver mail, or using the SMTP protocol for delivering\nmail via a remote server. Zend Framework also includes a \"File\" transport, which\ncreates a mail file for each message sent; these can later be introspected as\nlogs or consumed for the purposes of sending via an alternate transport\nmechanism later.  The  Zend\\Mail\\Transport  interface defines exactly one method,  send() . This\nmethod accepts a  Zend\\Mail\\Message  instance, which it then introspects and\nserializes in order to send.", 
            "title": "Transports"
        }, 
        {
            "location": "/transport/intro/#quick-start", 
            "text": "Using a mail transport involves instantiating it, optionally configuring it, and\nthen passing a message to it.", 
            "title": "Quick Start"
        }, 
        {
            "location": "/transport/intro/#sendmail-transport-usage", 
            "text": "use Zend\\Mail\\Message;\nuse Zend\\Mail\\Transport\\Sendmail as SendmailTransport;\n\n$message = new Message();\n$message- addTo('matthew@example.org');\n$message- addFrom('ralph@example.org');\n$message- setSubject('Greetings and Salutations!');\n$message- setBody( Sorry, I'm going to be late today! );\n\n$transport = new SendmailTransport();\n$transport- send($message);", 
            "title": "Sendmail Transport Usage"
        }, 
        {
            "location": "/transport/intro/#smtp-transport-usage", 
            "text": "use Zend\\Mail\\Message;\nuse Zend\\Mail\\Transport\\Smtp as SmtpTransport;\nuse Zend\\Mail\\Transport\\SmtpOptions;\n\n$message = new Message();\n$message- addTo('matthew@example.org');\n$message- addFrom('ralph@example.org');\n$message- setSubject('Greetings and Salutations!');\n$message- setBody( Sorry, I'm going to be late today! );\n\n// Setup SMTP transport using LOGIN authentication\n$transport = new SmtpTransport();\n$options   = new SmtpOptions([\n    'name'              =  'localhost.localdomain',\n    'host'              =  '127.0.0.1',\n    'connection_class'  =  'login',\n    'connection_config' =  [\n        'username' =  'user',\n        'password' =  'pass',\n    ],\n]);\n$transport- setOptions($options);\n$transport- send($message);", 
            "title": "SMTP Transport Usage"
        }, 
        {
            "location": "/transport/intro/#file-transport-usage", 
            "text": "use Zend\\Mail\\Message;\nuse Zend\\Mail\\Transport\\File as FileTransport;\nuse Zend\\Mail\\Transport\\FileOptions;\nuse Zend\\Math\\Rand;\n\n$message = new Message();\n$message- addTo('matthew@example.org');\n$message- addFrom('ralph@example.org');\n$message- setSubject('Greetings and Salutations!');\n$message- setBody( Sorry, I'm going to be late today! );\n\n// Setup File transport\n$transport = new FileTransport();\n$options   = new FileOptions([\n    'path'     =  'data/mail/',\n    'callback' =  function (FileTransport $transport) {\n        return sprintf(\n            'Message_%f_%s.txt',\n            microtime(true),\n            Rand::getString(8)\n        );\n    },\n]);\n$transport- setOptions($options);\n$transport- send($message);", 
            "title": "File Transport Usage"
        }, 
        {
            "location": "/transport/intro/#inmemory-transport-usage", 
            "text": "use Zend\\Mail\\Message;\nuse Zend\\Mail\\Transport\\InMemory as InMemoryTransport;\n\n$message = new Message();\n$message- addTo('matthew@example.org');\n$message- addFrom('ralph@example.org');\n$message- setSubject('Greetings and Salutations!');\n$message- setBody( Sorry, I'm going to be late today! );\n\n// Setup InMemory transport\n$transport = new InMemoryTransport();\n$transport- send($message);\n\n// Verify the message:\n$received = $transport- getLastMessage();  The  InMemory  transport is primarily of interest when in development or when\ntesting.", 
            "title": "InMemory Transport Usage"
        }, 
        {
            "location": "/transport/intro/#migration-from-20-23-to-24", 
            "text": "Version 2.4 adds support for PHP 7. In PHP 7,  null  is a reserved keyword,\nwhich required renaming the  Null  transport. If you were using the  Null \ntransport directly previously, you will now receive an  E_USER_DEPRECATED \nnotice on instantiation. Please update your code to refer to the  InMemory \nclass instead.  Users pulling their  Null  transport instance from the transport factory\n( Zend\\Mail\\Transport\\Factory ) receive an  InMemory  instance instead starting\nin 2.4.0.", 
            "title": "Migration from 2.0-2.3 to 2.4+"
        }, 
        {
            "location": "/transport/intro/#configuration-options", 
            "text": "Configuration options are per transport. Please follow the links below for\ntransport-specific options.   SMTP Transport Options  File Transport Options", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/transport/intro/#available-methods", 
            "text": "", 
            "title": "Available Methods"
        }, 
        {
            "location": "/transport/intro/#send", 
            "text": "send(Zend\\Mail\\Message $message) : void  Send a mail message.", 
            "title": "send"
        }, 
        {
            "location": "/transport/smtp-options/", 
            "text": "SMTP Transport Options\n\n\nThis document details the various options available to the\n\nZend\\Mail\\Transport\\Smtp\n mail transport.\n\n\nQuick Start\n\n\nBasic SMTP Transport Usage\n\n\nuse Zend\\Mail\\Transport\\Smtp as SmtpTransport;\nuse Zend\\Mail\\Transport\\SmtpOptions;\n\n// Setup SMTP transport\n$transport = new SmtpTransport();\n$options   = new SmtpOptions([\n    'name' =\n 'localhost.localdomain',\n    'host' =\n '127.0.0.1',\n    'port' =\n 25,\n]);\n$transport-\nsetOptions($options);\n\n\n\n\nIf you require authentication, see the section on \nSMTP authentication\n\nfor examples of configuring authentication credentials.\n\n\nConfiguration Options\n\n\n\n\n\n\n\n\nOption name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nname\n\n\nName of the SMTP host; defaults to \"localhost\".\n\n\n\n\n\n\nhost\n\n\nRemote hostname or IP address; defaults to \"127.0.0.1\".\n\n\n\n\n\n\nport\n\n\nPort on which the remote host is listening; defaults to \"25\".\n\n\n\n\n\n\nconnection_class\n\n\nFully-qualified classname or short name resolvable via \nZend\\Mail\\Protocol\\SmtpPluginManager\n. See the \nSMTP authentication\n documentation for details.\n\n\n\n\n\n\nconnection_config\n\n\nOptional associative array of parameters to pass to the connection class in order to configure it. By default, this is empty. See the \nSMTP authentication\n documentation for details.\n\n\n\n\n\n\n\n\nAvailable Methods\n\n\ngetName\n\n\ngetName() : string\n\n\n\n\nReturns the string name of the local client hostname.\n\n\nsetName\n\n\nsetName(string $name) : void\n\n\n\n\nSet the string name of the local client hostname.\n\n\ngetConnectionClass\n\n\ngetConnectionClass() : string\n\n\n\n\nReturns a string indicating the connection class name to use.\n\n\nsetConnectionClass\n\n\nsetConnectionClass(string $connectionClass) : void\n\n\n\n\nSet the connection class to use.\n\n\ngetConnectionConfig\n\n\ngetConnectionConfig() : array\n\n\n\n\nGet configuration for the connection class.\n\n\nsetConnectionConfig\n\n\nsetConnectionConfig(array $config) : void\n\n\n\n\nSet configuration for the connection class. Typically, if using anything other\nthan the default connection class, this will be an associative array with the\nkeys \"username\" and \"password\".\n\n\ngetHost\n\n\ngetHost() : string\n\n\n\n\nReturns a string indicating the IP address or host name of the SMTP server via\nwhich to send messages.\n\n\nsetHost\n\n\nsetHost(string $host) : void\n\n\n\n\nSet the SMTP host name or IP address.\n\n\ngetPort\n\n\ngetPort() : int\n\n\n\n\nRetrieve the integer port on which the SMTP host is listening.\n\n\nsetPort\n\n\nsetPort(int $port) : void\n\n\n\n\nSet the port on which the SMTP host is listening.\n\n\n__construct\n\n\n__construct(null|array|Traversable $config) : void\n\n\n\n\nInstantiate the class, and optionally configure it with values provided.", 
            "title": "SMTP Options"
        }, 
        {
            "location": "/transport/smtp-options/#smtp-transport-options", 
            "text": "This document details the various options available to the Zend\\Mail\\Transport\\Smtp  mail transport.", 
            "title": "SMTP Transport Options"
        }, 
        {
            "location": "/transport/smtp-options/#quick-start", 
            "text": "", 
            "title": "Quick Start"
        }, 
        {
            "location": "/transport/smtp-options/#basic-smtp-transport-usage", 
            "text": "use Zend\\Mail\\Transport\\Smtp as SmtpTransport;\nuse Zend\\Mail\\Transport\\SmtpOptions;\n\n// Setup SMTP transport\n$transport = new SmtpTransport();\n$options   = new SmtpOptions([\n    'name' =  'localhost.localdomain',\n    'host' =  '127.0.0.1',\n    'port' =  25,\n]);\n$transport- setOptions($options);  If you require authentication, see the section on  SMTP authentication \nfor examples of configuring authentication credentials.", 
            "title": "Basic SMTP Transport Usage"
        }, 
        {
            "location": "/transport/smtp-options/#configuration-options", 
            "text": "Option name  Description      name  Name of the SMTP host; defaults to \"localhost\".    host  Remote hostname or IP address; defaults to \"127.0.0.1\".    port  Port on which the remote host is listening; defaults to \"25\".    connection_class  Fully-qualified classname or short name resolvable via  Zend\\Mail\\Protocol\\SmtpPluginManager . See the  SMTP authentication  documentation for details.    connection_config  Optional associative array of parameters to pass to the connection class in order to configure it. By default, this is empty. See the  SMTP authentication  documentation for details.", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/transport/smtp-options/#available-methods", 
            "text": "", 
            "title": "Available Methods"
        }, 
        {
            "location": "/transport/smtp-options/#getname", 
            "text": "getName() : string  Returns the string name of the local client hostname.", 
            "title": "getName"
        }, 
        {
            "location": "/transport/smtp-options/#setname", 
            "text": "setName(string $name) : void  Set the string name of the local client hostname.", 
            "title": "setName"
        }, 
        {
            "location": "/transport/smtp-options/#getconnectionclass", 
            "text": "getConnectionClass() : string  Returns a string indicating the connection class name to use.", 
            "title": "getConnectionClass"
        }, 
        {
            "location": "/transport/smtp-options/#setconnectionclass", 
            "text": "setConnectionClass(string $connectionClass) : void  Set the connection class to use.", 
            "title": "setConnectionClass"
        }, 
        {
            "location": "/transport/smtp-options/#getconnectionconfig", 
            "text": "getConnectionConfig() : array  Get configuration for the connection class.", 
            "title": "getConnectionConfig"
        }, 
        {
            "location": "/transport/smtp-options/#setconnectionconfig", 
            "text": "setConnectionConfig(array $config) : void  Set configuration for the connection class. Typically, if using anything other\nthan the default connection class, this will be an associative array with the\nkeys \"username\" and \"password\".", 
            "title": "setConnectionConfig"
        }, 
        {
            "location": "/transport/smtp-options/#gethost", 
            "text": "getHost() : string  Returns a string indicating the IP address or host name of the SMTP server via\nwhich to send messages.", 
            "title": "getHost"
        }, 
        {
            "location": "/transport/smtp-options/#sethost", 
            "text": "setHost(string $host) : void  Set the SMTP host name or IP address.", 
            "title": "setHost"
        }, 
        {
            "location": "/transport/smtp-options/#getport", 
            "text": "getPort() : int  Retrieve the integer port on which the SMTP host is listening.", 
            "title": "getPort"
        }, 
        {
            "location": "/transport/smtp-options/#setport", 
            "text": "setPort(int $port) : void  Set the port on which the SMTP host is listening.", 
            "title": "setPort"
        }, 
        {
            "location": "/transport/smtp-options/#9595construct", 
            "text": "__construct(null|array|Traversable $config) : void  Instantiate the class, and optionally configure it with values provided.", 
            "title": "__construct"
        }, 
        {
            "location": "/transport/smtp-multiple-send/", 
            "text": "Sending Multiple Mails per SMTP Connection\n\n\nBy default, a single SMTP transport creates a single connection and re-uses it\nfor the lifetime of the script execution. You may send multiple e-mails through\nthis SMTP connection. A \nRSET\n command is issued before each delivery to ensure\nthe correct SMTP handshake is followed.\n\n\nExamples\n\n\nSending Multiple Mails per SMTP Connection\n\n\nuse Zend\\Mail\\Message;\nuse Zend\\Mail\\Transport\\Smtp;\n\n// Create transport\n$transport = new Smtp([\n    'host' =\n 'mail.example.com'\n]);\n\n// Create a base message:\n$template = new Message();\n$template-\naddFrom('sender@example.com', 'John Doe');\n$template-\naddReplyTo('replyto@example.com', 'Jane Doe');\n$template-\nsetSubject('Demo of multiple mails per SMTP connection');\n$template-\nsetBody('... Your message here ...');\n\n// Loop through recipients:\nforeach ($recipients as $address) {\n    // Clone the message and add a recipient:\n    $message = clone $template;\n    $message-\naddTo($template);\n\n    $transport-\nsend($message);\n}\n\n\n\n\nIf you wish to have a separate connection for each mail delivery, you will need\nto create and destroy your transport before and after each \nsend()\n method is\ncalled.\n\n\nManipulating the transport between messages\n\n\nYou can manipulate the connection between each delivery by accessing the\ntransport's protocol object.\n\n\nuse Zend\\Mail\\Message;\nuse Zend\\Mail\\Protocol\\Smtp as SmtpProtocol;\nuse Zend\\Mail\\Transport\\Smtp as SmtpTransport;\n\n// Create transport\n$transport = new SmtpTransport();\n\n$protocol = new SmtpProtocol('mail.example.com');\n$protocol-\nconnect();\n$protocol-\nhelo('sender.example.com');\n\n$transport-\nsetConnection($protocol);\n\n// Loop through messages\nforeach ($recipients as $address) {\n    $mail = new Message();\n    $mail-\naddTo($address);\n    $mail-\nsetFrom('studio@example.com', 'Test');\n    $mail-\nsetSubject(\n        'Demonstration - Sending Multiple Mails per SMTP Connection'\n    );\n    $mail-\nsetBodyText('...Your message here...');\n\n    // Manually control the connection\n    $protocol-\nrset();\n    $transport-\nsend($message);\n}\n\n$protocol-\nquit();\n$protocol-\ndisconnect();", 
            "title": "Sending multiple messages"
        }, 
        {
            "location": "/transport/smtp-multiple-send/#sending-multiple-mails-per-smtp-connection", 
            "text": "By default, a single SMTP transport creates a single connection and re-uses it\nfor the lifetime of the script execution. You may send multiple e-mails through\nthis SMTP connection. A  RSET  command is issued before each delivery to ensure\nthe correct SMTP handshake is followed.", 
            "title": "Sending Multiple Mails per SMTP Connection"
        }, 
        {
            "location": "/transport/smtp-multiple-send/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/transport/smtp-multiple-send/#sending-multiple-mails-per-smtp-connection_1", 
            "text": "use Zend\\Mail\\Message;\nuse Zend\\Mail\\Transport\\Smtp;\n\n// Create transport\n$transport = new Smtp([\n    'host' =  'mail.example.com'\n]);\n\n// Create a base message:\n$template = new Message();\n$template- addFrom('sender@example.com', 'John Doe');\n$template- addReplyTo('replyto@example.com', 'Jane Doe');\n$template- setSubject('Demo of multiple mails per SMTP connection');\n$template- setBody('... Your message here ...');\n\n// Loop through recipients:\nforeach ($recipients as $address) {\n    // Clone the message and add a recipient:\n    $message = clone $template;\n    $message- addTo($template);\n\n    $transport- send($message);\n}  If you wish to have a separate connection for each mail delivery, you will need\nto create and destroy your transport before and after each  send()  method is\ncalled.", 
            "title": "Sending Multiple Mails per SMTP Connection"
        }, 
        {
            "location": "/transport/smtp-multiple-send/#manipulating-the-transport-between-messages", 
            "text": "You can manipulate the connection between each delivery by accessing the\ntransport's protocol object.  use Zend\\Mail\\Message;\nuse Zend\\Mail\\Protocol\\Smtp as SmtpProtocol;\nuse Zend\\Mail\\Transport\\Smtp as SmtpTransport;\n\n// Create transport\n$transport = new SmtpTransport();\n\n$protocol = new SmtpProtocol('mail.example.com');\n$protocol- connect();\n$protocol- helo('sender.example.com');\n\n$transport- setConnection($protocol);\n\n// Loop through messages\nforeach ($recipients as $address) {\n    $mail = new Message();\n    $mail- addTo($address);\n    $mail- setFrom('studio@example.com', 'Test');\n    $mail- setSubject(\n        'Demonstration - Sending Multiple Mails per SMTP Connection'\n    );\n    $mail- setBodyText('...Your message here...');\n\n    // Manually control the connection\n    $protocol- rset();\n    $transport- send($message);\n}\n\n$protocol- quit();\n$protocol- disconnect();", 
            "title": "Manipulating the transport between messages"
        }, 
        {
            "location": "/transport/smtp-authentication/", 
            "text": "SMTP Authentication\n\n\nzend-mail supports the use of SMTP authentication, which can be enabled via\nconfiguration.  The available built-in authentication methods are PLAIN, LOGIN,\nand CRAM-MD5, all of which expect 'username' and 'password' values in the\nconfiguration array.\n\n\nConfiguration\n\n\nIn order to enable authentication, ou need to specify a \"connection class\" and\nconnection configuration when configuring your SMTP transport. The two settings\nare briefly covered in the \nSMTP transport configuration options\n. Below are more details.\n\n\nconnection_class\n\n\nThe connection class should be a fully qualified class name of a\n\nZend\\Mail\\Protocol\\Smtp\\Auth\\*\n class or extension, or the short name (name\nwithout leading namespace). zend-mail ships with the following:\n\n\n\n\nZend\\Mail\\Protoco\\Smtp\\Auth\\Plain\n, or \nplain\n\n\nZend\\Mail\\Protoco\\Smtp\\Auth\\Login\n, or \nlogin\n\n\nZend\\Mail\\Protoco\\Smtp\\Auth\\Crammd5\n, or \ncrammd5\n\n\n\n\nCustom connection classes must be extensions of \nZend\\Mail\\Protocol\\Smtp\n.\n\n\nconnection_config\n\n\nThe \nconnection_config\n should be an associative array of options to provide to\nthe underlying connection class. All shipped connection classes require:\n\n\n\n\nusername\n\n\npassword\n\n\n\n\nOptionally, ou may also provide:\n\n\n\n\nssl\n: either the value \nssl\n or \ntls\n.\n\n\nport\n: if using something other than the default port for the protocol used.\n  Port 25 is the default used for non-SSL connections, 465 for SSL, and 587 for\n  TLS.\n\n\n\n\nExamples\n\n\nSMTP Transport Usage with PLAIN AUTH\n\n\nuse Zend\\Mail\\Transport\\Smtp as SmtpTransport;\nuse Zend\\Mail\\Transport\\SmtpOptions;\n\n// Setup SMTP transport using PLAIN authentication\n$transport = new SmtpTransport();\n$options   = new SmtpOptions([\n    'name'              =\n 'localhost.localdomain',\n    'host'              =\n '127.0.0.1',\n    'connection_class'  =\n 'plain',\n    'connection_config' =\n [\n        'username' =\n 'user',\n        'password' =\n 'pass',\n    ],\n]);\n$transport-\nsetOptions($options);\n\n\n\n\nSMTP Transport Usage with LOGIN AUTH\n\n\nuse Zend\\Mail\\Transport\\Smtp as SmtpTransport;\nuse Zend\\Mail\\Transport\\SmtpOptions;\n\n// Setup SMTP transport using LOGIN authentication\n$transport = new SmtpTransport();\n$options   = new SmtpOptions([\n    'name'              =\n 'localhost.localdomain',\n    'host'              =\n '127.0.0.1',\n    'connection_class'  =\n 'login',\n    'connection_config' =\n [\n        'username' =\n 'user',\n        'password' =\n 'pass',\n    ],\n]);\n$transport-\nsetOptions($options);\n\n\n\n\nSMTP Transport Usage with CRAM-MD5 AUTH\n\n\nuse Zend\\Mail\\Transport\\Smtp as SmtpTransport;\nuse Zend\\Mail\\Transport\\SmtpOptions;\n\n// Setup SMTP transport using CRAM-MD5 authentication\n$transport = new SmtpTransport();\n$options   = new SmtpOptions([\n    'name'              =\n 'localhost.localdomain',\n    'host'              =\n '127.0.0.1',\n    'connection_class'  =\n 'crammd5',\n    'connection_config' =\n [\n        'username' =\n 'user',\n        'password' =\n 'pass',\n    ],\n]);\n$transport-\nsetOptions($options);\n\n\n\n\nSMTP Transport Usage with PLAIN AUTH over TLS\n\n\nuse Zend\\Mail\\Transport\\Smtp as SmtpTransport;\nuse Zend\\Mail\\Transport\\SmtpOptions;\n\n// Setup SMTP transport using PLAIN authentication over TLS\n$transport = new SmtpTransport();\n$options   = new SmtpOptions([\n    'name'              =\n 'example.com',\n    'host'              =\n '127.0.0.1',\n    'port'              =\n 587,\n    // Notice port change for TLS is 587\n    'connection_class'  =\n 'plain',\n    'connection_config' =\n [\n        'username' =\n 'user',\n        'password' =\n 'pass',\n        'ssl'      =\n 'tls',\n    ],\n]);\n$transport-\nsetOptions($options);", 
            "title": "Authentication"
        }, 
        {
            "location": "/transport/smtp-authentication/#smtp-authentication", 
            "text": "zend-mail supports the use of SMTP authentication, which can be enabled via\nconfiguration.  The available built-in authentication methods are PLAIN, LOGIN,\nand CRAM-MD5, all of which expect 'username' and 'password' values in the\nconfiguration array.", 
            "title": "SMTP Authentication"
        }, 
        {
            "location": "/transport/smtp-authentication/#configuration", 
            "text": "In order to enable authentication, ou need to specify a \"connection class\" and\nconnection configuration when configuring your SMTP transport. The two settings\nare briefly covered in the  SMTP transport configuration options . Below are more details.", 
            "title": "Configuration"
        }, 
        {
            "location": "/transport/smtp-authentication/#connection_class", 
            "text": "The connection class should be a fully qualified class name of a Zend\\Mail\\Protocol\\Smtp\\Auth\\*  class or extension, or the short name (name\nwithout leading namespace). zend-mail ships with the following:   Zend\\Mail\\Protoco\\Smtp\\Auth\\Plain , or  plain  Zend\\Mail\\Protoco\\Smtp\\Auth\\Login , or  login  Zend\\Mail\\Protoco\\Smtp\\Auth\\Crammd5 , or  crammd5   Custom connection classes must be extensions of  Zend\\Mail\\Protocol\\Smtp .", 
            "title": "connection_class"
        }, 
        {
            "location": "/transport/smtp-authentication/#connection_config", 
            "text": "The  connection_config  should be an associative array of options to provide to\nthe underlying connection class. All shipped connection classes require:   username  password   Optionally, ou may also provide:   ssl : either the value  ssl  or  tls .  port : if using something other than the default port for the protocol used.\n  Port 25 is the default used for non-SSL connections, 465 for SSL, and 587 for\n  TLS.", 
            "title": "connection_config"
        }, 
        {
            "location": "/transport/smtp-authentication/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/transport/smtp-authentication/#smtp-transport-usage-with-plain-auth", 
            "text": "use Zend\\Mail\\Transport\\Smtp as SmtpTransport;\nuse Zend\\Mail\\Transport\\SmtpOptions;\n\n// Setup SMTP transport using PLAIN authentication\n$transport = new SmtpTransport();\n$options   = new SmtpOptions([\n    'name'              =  'localhost.localdomain',\n    'host'              =  '127.0.0.1',\n    'connection_class'  =  'plain',\n    'connection_config' =  [\n        'username' =  'user',\n        'password' =  'pass',\n    ],\n]);\n$transport- setOptions($options);", 
            "title": "SMTP Transport Usage with PLAIN AUTH"
        }, 
        {
            "location": "/transport/smtp-authentication/#smtp-transport-usage-with-login-auth", 
            "text": "use Zend\\Mail\\Transport\\Smtp as SmtpTransport;\nuse Zend\\Mail\\Transport\\SmtpOptions;\n\n// Setup SMTP transport using LOGIN authentication\n$transport = new SmtpTransport();\n$options   = new SmtpOptions([\n    'name'              =  'localhost.localdomain',\n    'host'              =  '127.0.0.1',\n    'connection_class'  =  'login',\n    'connection_config' =  [\n        'username' =  'user',\n        'password' =  'pass',\n    ],\n]);\n$transport- setOptions($options);", 
            "title": "SMTP Transport Usage with LOGIN AUTH"
        }, 
        {
            "location": "/transport/smtp-authentication/#smtp-transport-usage-with-cram-md5-auth", 
            "text": "use Zend\\Mail\\Transport\\Smtp as SmtpTransport;\nuse Zend\\Mail\\Transport\\SmtpOptions;\n\n// Setup SMTP transport using CRAM-MD5 authentication\n$transport = new SmtpTransport();\n$options   = new SmtpOptions([\n    'name'              =  'localhost.localdomain',\n    'host'              =  '127.0.0.1',\n    'connection_class'  =  'crammd5',\n    'connection_config' =  [\n        'username' =  'user',\n        'password' =  'pass',\n    ],\n]);\n$transport- setOptions($options);", 
            "title": "SMTP Transport Usage with CRAM-MD5 AUTH"
        }, 
        {
            "location": "/transport/smtp-authentication/#smtp-transport-usage-with-plain-auth-over-tls", 
            "text": "use Zend\\Mail\\Transport\\Smtp as SmtpTransport;\nuse Zend\\Mail\\Transport\\SmtpOptions;\n\n// Setup SMTP transport using PLAIN authentication over TLS\n$transport = new SmtpTransport();\n$options   = new SmtpOptions([\n    'name'              =  'example.com',\n    'host'              =  '127.0.0.1',\n    'port'              =  587,\n    // Notice port change for TLS is 587\n    'connection_class'  =  'plain',\n    'connection_config' =  [\n        'username' =  'user',\n        'password' =  'pass',\n        'ssl'      =  'tls',\n    ],\n]);\n$transport- setOptions($options);", 
            "title": "SMTP Transport Usage with PLAIN AUTH over TLS"
        }, 
        {
            "location": "/transport/file-options/", 
            "text": "File Transport Options\n\n\nThis document details the various options available to the\n\nZend\\Mail\\Transport\\File\n mail transport.\n\n\nQuick Start\n\n\nuse Zend\\Mail\\Transport\\File as FileTransport;\nuse Zend\\Mail\\Transport\\FileOptions;\n\n// Setup File transport\n$transport = new FileTransport();\n$options   = new FileOptions([\n    'path'     =\n 'data/mail/',\n    'callback' =\n function (FileTransport $transport) {\n        return 'Message_' . microtime(true) . '_' . mt_rand() . '.txt';\n    },\n]);\n$transport-\nsetOptions($options);\n\n\n\n\nConfiguration Options\n\n\n\n\n\n\n\n\nOption name\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\npath\n\n\nThe path under which mail files will be written.\n\n\n\n\n\n\ncallback\n\n\nA PHP callable to be invoked in order to generate a unique name for a message file. See below for the default used.\n\n\n\n\n\n\n\n\nThe default callback used is:\n\n\nfunction (Zend\\Mail\\FileTransport $transport) {\n    return 'ZendMail_' . time() . '_' . mt_rand() . '.tmp';\n}\n\n\n\n\nAvailable Methods\n\n\nZend\\Mail\\Transport\\FileOptions\n extends \nZend\\Stdlib\\AbstractOptions\n, and\ninherits all functionality from that class; this includes property overloading.\nAdditionally, the following explicit setters and getters are provided.\n\n\nsetPath\n\n\nsetPath(string $path) : void\n\n\n\n\nSet the path under which mail files will be written.\n\n\ngetPath\n\n\ngetPath() : string\n\n\n\n\nGet the path under which mail files will be written.\n\n\nsetCallback\n\n\nsetCallback(callable $callback) : void\n\n\n\n\nSet the callback used to generate unique filenames for messages.\n\n\ngetCallback\n\n\ngetCallback() : callable\n\n\n\n\nGet the callback used to generate unique filenames for messages.\n\n\n__construct\n\n\n__construct(null|array|Traversable $config) : void\n\n\n\n\nInitialize the object. Allows passing a PHP array or \nTraversable\n object with\nwhich to populate the instance.", 
            "title": "File Transport Options"
        }, 
        {
            "location": "/transport/file-options/#file-transport-options", 
            "text": "This document details the various options available to the Zend\\Mail\\Transport\\File  mail transport.", 
            "title": "File Transport Options"
        }, 
        {
            "location": "/transport/file-options/#quick-start", 
            "text": "use Zend\\Mail\\Transport\\File as FileTransport;\nuse Zend\\Mail\\Transport\\FileOptions;\n\n// Setup File transport\n$transport = new FileTransport();\n$options   = new FileOptions([\n    'path'     =  'data/mail/',\n    'callback' =  function (FileTransport $transport) {\n        return 'Message_' . microtime(true) . '_' . mt_rand() . '.txt';\n    },\n]);\n$transport- setOptions($options);", 
            "title": "Quick Start"
        }, 
        {
            "location": "/transport/file-options/#configuration-options", 
            "text": "Option name  Description      path  The path under which mail files will be written.    callback  A PHP callable to be invoked in order to generate a unique name for a message file. See below for the default used.     The default callback used is:  function (Zend\\Mail\\FileTransport $transport) {\n    return 'ZendMail_' . time() . '_' . mt_rand() . '.tmp';\n}", 
            "title": "Configuration Options"
        }, 
        {
            "location": "/transport/file-options/#available-methods", 
            "text": "Zend\\Mail\\Transport\\FileOptions  extends  Zend\\Stdlib\\AbstractOptions , and\ninherits all functionality from that class; this includes property overloading.\nAdditionally, the following explicit setters and getters are provided.", 
            "title": "Available Methods"
        }, 
        {
            "location": "/transport/file-options/#setpath", 
            "text": "setPath(string $path) : void  Set the path under which mail files will be written.", 
            "title": "setPath"
        }, 
        {
            "location": "/transport/file-options/#getpath", 
            "text": "getPath() : string  Get the path under which mail files will be written.", 
            "title": "getPath"
        }, 
        {
            "location": "/transport/file-options/#setcallback", 
            "text": "setCallback(callable $callback) : void  Set the callback used to generate unique filenames for messages.", 
            "title": "setCallback"
        }, 
        {
            "location": "/transport/file-options/#getcallback", 
            "text": "getCallback() : callable  Get the callback used to generate unique filenames for messages.", 
            "title": "getCallback"
        }, 
        {
            "location": "/transport/file-options/#9595construct", 
            "text": "__construct(null|array|Traversable $config) : void  Initialize the object. Allows passing a PHP array or  Traversable  object with\nwhich to populate the instance.", 
            "title": "__construct"
        }, 
        {
            "location": "/read/", 
            "text": "Reading and Storing Mail\n\n\nzend-mail can read mail messages from several local or remote mail storage\ntypes. Storage adapters share the same API for counting and fetching messages,\nand some of them implement additional interfaces for less common features. For a\nfeature overview of the implemented storages, see the following table.\n\n\n\n\n\n\n\n\nFeature\n\n\nMbox\n\n\nMaildir\n\n\nPop3\n\n\nIMAP\n\n\n\n\n\n\n\n\n\n\nStorage type\n\n\nlocal\n\n\nlocal\n\n\nremote\n\n\nremote\n\n\n\n\n\n\nFetch message\n\n\nYes\n\n\nYes\n\n\nYes\n\n\nYes\n\n\n\n\n\n\nFetch MIME-part\n\n\nemulated\n\n\nemulated\n\n\nemulated\n\n\nemulated\n\n\n\n\n\n\nFolders\n\n\nYes\n\n\nYes\n\n\nNo\n\n\nYes\n\n\n\n\n\n\nCreate message/folder\n\n\nNo\n\n\ntodo\n\n\nNo\n\n\ntodo\n\n\n\n\n\n\nFlags\n\n\nNo\n\n\nYes\n\n\nNo\n\n\nYes\n\n\n\n\n\n\nQuota\n\n\nNo\n\n\nYes\n\n\nNo\n\n\nNo\n\n\n\n\n\n\n\n\nStorage adapters return instances of \nZend\\Mail\\Storage\\Message\n, which has a\ndifferent API than \nmessages used when sending\n; the API is\ndescribed in the \n\"Working with messages\"\n section.\n\n\nBasic POP3 example\n\n\nuse Zend\\Mail\\Storage\\Pop3;\n\n$mail = Pop3([\n    'host'     =\n 'localhost',\n    'user'     =\n 'test',\n    'password' =\n 'test',\n]);\n\necho $mail-\ncountMessages() . \n messages found\\n\n;\nforeach ($mail as $message) {\n    printf(\nMail from '%s': %s\\n\n, $message-\nfrom, $message-\nsubject);\n}\n\n\n\n\nUsing local storage via mbox and maildir\n\n\nMbox and Maildir are the two supported formats for local mail storage.\n\n\nIf you want to read from an mbox file, provide the filename to the constructor\nof \nZend\\Mail\\Storage\\Mbox\n:\n\n\nuse Zend\\Mail\\Storage\\Mbox;\n\n$mail = new Mbox(['filename' =\n '/home/test/mail/inbox']);\n\n\n\n\nMaildir operates similarly, but requires a dirname instead:\n\n\nuse Zend\\Mail\\Storage\\Maildir;\n$mail = new Maildir(['dirname' =\n '/home/test/mail/']);\n\n\n\n\nBoth constructors throw a \nZend\\Mail\\Exception\n if the storage can't be read.\n\n\nUsing remote storage protocols\n\n\nFor remote storage, the two most popular protocols are supported: POP3 and IMAP.\nBoth need at least a host and a user to connect and login. The default password\nis an empty string, and the default port for the protocol is used if none is\nprovided.\n\n\nuse Zend\\Mail\\Storage\\Imap;\nuse Zend\\Mail\\Storage\\Pop3;\n\n// Connecting with Pop3:\n$mail = Pop3([\n    'host'     =\n 'example.com',\n    'user'     =\n 'test',\n    'password' =\n 'test',\n]);\n\n// Connecting with Imap:\n$mail = new Imap([\n    'host'     =\n 'example.com',\n    'user'     =\n 'test',\n    'password' =\n 'test',\n]);\n\n// Example of using POP3 on a non-standard port:\n$mail = new Pop3([\n    'host'     =\n 'example.com',\n    'port'     =\n 1120,\n    'user'     =\n 'test',\n    'password' =\n 'test',\n]);\n\n\n\n\nBoth storage adapters support SSL and TLS. If you use SSL, the default port\nchanges as specified in the relevant RFC.\n\n\nuse Zend\\Mail\\Storage\\Pop3;\n\n// Examples use Pop3; the same configuration works for Imap.\n\n// Use SSL on a non-standard port (default is 995 for Pop3 and 993 for Imap)\n$mail = new Pop3([\n    'host'     =\n 'example.com',\n    'user'     =\n 'test',\n    'password' =\n 'test',\n    'ssl'      =\n 'SSL',\n]);\n\n// use TLS on the default port:\n$mail = new Pop3([\n    'host'     =\n 'example.com',\n    'user'     =\n 'test',\n    'password' =\n 'test',\n    'ssl'      =\n 'TLS',\n]);\n\n\n\n\nBoth constructors throw \nZend\\Mail\\Exception\n or \nZend\\Mail\\Protocol\\Exception\n\n(extends \nZend\\Mail\\Exception\n) for connection errors, depending on the type of\nerror encountered.\n\n\nFetching, counting, and removing messages\n\n\nOnce you have opened the mail storage, you may fetch messages. To do so, you\nneed the message number, which is a counter starting with 1 for the first\nmessage. To fetch the message, you use the method \ngetMessage()\n:\n\n\n$message = $mail-\ngetMessage($messageNum);\n\n\n\n\nArray access is also supported, but this access method does not support any\nadditional parameters that could be added to \ngetMessage()\n. As long as you\ndon't mind, and can live with the default values, you may use:\n\n\n$message = $mail[$messageNum];\n\n\n\n\nFor iterating over all messages the \nIterator\n interface is implemented:\n\n\nforeach ($mail as $messageNum =\n $message) {\n    // do stuff ...\n}\n\n\n\n\nTo count the messages in the storage, you can use the method\n\ncountMessages()\n; alternately, storage adapters implement \nCountable\n, allowing\nyou to \ncount()\n the instance.\n\n\n// method\n$maxMessage = $mail-\ncountMessages();\n\n// array access\n$maxMessage = count($mail);\n\n\n\n\nTo remove a mail, use the method \nremoveMessage()\n, or rely on array access and\nuse \nunset()\n:\n\n\n// method\n$mail-\nremoveMessage($messageNum);\n\n// array access\nunset($mail[$messageNum]);\n\n\n\n\nWorking with messages\n\n\nAfter you fetch a message, you can:\n\n\n\n\nfetch headers\n\n\nfetch the message content\n\n\nfetch individual parts of multipart messages\n\n\n\n\nAll headers can be accessed as message instance properties or via the method\n\ngetHeader()\n; use the latter for messages with compound names.  Header names\nare normalized to lowercase internally, but may be fetched using any case\nstructure; dash-separated headers may be fetched using camelCase notation. If no\nheader matching the name is found, an exception is thrown; use the\n\nheaderExists()\n method (or \nisset($message-\nheaderName)\n) to test for header\nexistence prior to retrieval.\n\n\n// get the message object\n$message = $mail-\ngetMessage(1);\n\n// output subject of message\necho $message-\nsubject . \n\\n\n;\n\n// get content-type header\n$type = $message-\ncontentType;\n\n// check if CC isset:\nif (isset($message-\ncc)) { // or $message-\nheaderExists('cc');\n    $cc = $message-\ncc;\n}\n\n\n\n\nIf you have multiple headers with the same name \n e.g. the \nReceived\n\nheaders \n you will want an array of values. Property access always returns\na string, so use \ngetHeader()\n instead for these situations:\n\n\n// get header as property - the result is always a string,\n// with new lines between each value.\n$received = $message-\nreceived;\n\n// The same via getHeader() method:\n$received = $message-\ngetHeader('received', 'string');\n\n// To retrieve an array of values:\n$received = $message-\ngetHeader('received', 'array');\nforeach ($received as $line) {\n    // do stuff\n}\n\n// If you don't define a format you'll get the internal representation\n// (string for single headers, array for multiple):\n$received = $message-\ngetHeader('received');\nif (is_string($received)) {\n    // only one received header found in message\n}\n\n\n\n\nThe method \ngetHeaders()\n returns all headers as an array with the lower-cased\nname as the key and the value as an array for multiple headers or as string for\nsingle headers.\n\n\n// dump all headers\nforeach ($message-\ngetHeaders() as $name =\n $value) {\n    if (is_string($value)) {\n        echo \n$name: $value\\n\n;\n        continue;\n    }\n    foreach ($value as $entry) {\n        echo \n$name: $entry\\n\n;\n    }\n}\n\n\n\n\nIf you don't have a multipart message, fetch the content via \ngetContent()\n.\nUnlike headers, the content is only fetched when needed (aka late-fetch).\n\n\n// output message content for HTML\necho '\npre\n';\necho $message-\ngetContent();\necho '\n/pre\n';\n\n\n\n\nChecking for multipart messages is done with the method \nisMultipart()\n. If you\nhave a multipart message you, can get retrieve the individual\n\nZend\\Mail\\Storage\\Part\n instances making up the message via the \ngetPart()\n\nmethod, which accepts the part index as a parameter (indices start with 1).\n\nZend\\Mail\\Storage\\Part\n is the base class of \nZend\\Mail\\Storage\\Message\n, and\nthus exposes the same API with regards to headers, content, and retrieving\nnested parts.\n\n\n// get the first non-multipart part\n$part = $message;\nwhile ($part-\nisMultipart()) {\n    $part = $message-\ngetPart(1);\n}\necho 'Type of this part is ' . strtok($part-\ncontentType, ';') . \n\\n\n;\necho \nContent:\\n\n;\necho $part-\ngetContent();\n\n\n\n\nZend\\Mail\\Storage\\Part\n also implements \nRecursiveIterator\n, which allows iterating\nthrough all parts, even when nested. Additionally, it implements the magic\nmethod \n__toString()\n, which returns the content.\n\n\nuse RecursiveIteratorIterator;\nuse Zend\\Mail\\Exception;\n\n// output first text/plain part\n$foundPart = null;\nforeach (new RecursiveIteratorIterator($mail-\ngetMessage(1)) as $part) {\n    try {\n        if (strtok($part-\ncontentType, ';') == 'text/plain') {\n            $foundPart = $part;\n            break;\n        }\n    } catch (Exception $e) {\n        // ignore\n    }\n}\nif (! $foundPart) {\n    echo 'no plain text part found';\n} else {\n    echo \nplain text part: \\n\n . $foundPart;\n}\n\n\n\n\nChecking for flags\n\n\nMaildir and IMAP support storing flags with messages. The \nZend\\Mail\\Storage\n\nclass defines constants for all known maildir and IMAP system flags, named\n\nFLAG_\nflagname\n. To check for flags, \nZend\\Mail\\Storage\\Message\n has\na method called \nhasFlag()\n. With \ngetFlags()\n you'll get all flags.\n\n\nuse Zend\\Mail\\Storage;\n\n// Find unread messages:\necho \nUnread mails:\\n\n;\nforeach ($mail as $message) {\n    if ($message-\nhasFlag(Storage::FLAG_SEEN)) {\n        continue;\n    }\n\n    // mark recent/new mails\n    echo ($message-\nhasFlag(Storage::FLAG_RECENT))\n        ? '! '\n        : '  ';\n\n    echo $message-\nsubject . \n\\n\n;\n}\n\n// Check for known flags\n$flags = $message-\ngetFlags();\necho 'Message is flagged as: ';\nforeach ($flags as $flag) {\n    switch ($flag) {\n        case Storage::FLAG_ANSWERED:\n            echo 'Answered ';\n            break;\n        case Storage::FLAG_FLAGGED:\n            echo 'Flagged ';\n            break;\n\n        // ...\n        // check for other flags\n        // ...\n\n        default:\n            echo $flag . '(unknown flag) ';\n    }\n}\n\n\n\n\nAs IMAP allows user or client defined flags, you could get flags that don't have\na constant in \nZend\\Mail\\Storage\n. Instead, they are returned as strings and can\nbe checked the same way with \nhasFlag()\n.\n\n\n// check message for client defined flags $IsSpam, $SpamTested\nif (! $message-\nhasFlag('$SpamTested')) {\n    echo 'message has not been tested for spam';\n} elseif ($message-\nhasFlag('$IsSpam')) {\n    echo 'this message is spam';\n} else {\n    echo 'this message is ham';\n}\n\n\n\n\nUsing folders\n\n\nAll storage adapters except POP3 support folders (also called \nmailboxes\n). The\ninterface implemented by all aadapters supporting folders is called\n\nZend\\Mail\\Storage\\Folder\\FolderInterface\n. Each also supports an optional\nconfiguration parameter called \nfolder\n, which is the folder selected after\nlogin.\n\n\nFor the local storage adapters, you need to use the adapter-specific folder\nclasses, \nZend\\Mail\\Storage\\Folder\\Mbox\n and \nZend\\Mail\\Storage\\Folder\\Maildir\n.\nEach accepts a single parameter, \ndirname\n, with the name of the base direcor.\nThe format for maildir is as defined in\n\nmaildir++\n (with a dot as\ndefault delimiter); mbox uses a directory hierarchy of mbox files. If you don't\nhave an mbox file called \nINBOX\n in your mbox base directory, you need to\nspecify another folder via the constructor.\n\n\nZend\\Mail\\Storage\\Imap\n supports folders by default.\n\n\nExamples for opening folders with each adapter:\n\n\nuse Zend\\Mail\\Storage\\Folder;\nuse Zend\\Mail\\Storage\\Imap;\n\n// mbox with folders:\n$mail = Folder\\Mbox(['dirname' =\n '/home/test/mail/']);\n\n// mbox with a default folder not called INBOX; also works\n// with the maildir and IMAP implemenations.\n$mail = new Folder\\Mbox([\n    'dirname' =\n '/home/test/mail/',\n    'folder'  =\n 'Archive',\n]);\n\n// maildir with folders:\n$mail = new Folder\\Maildir(['dirname' =\n '/home/test/mail/']);\n\n// maildir with colon as delimiter, as suggested in Maildir++:\n$mail = new Folder\\Maildir([\n    'dirname' =\n '/home/test/mail/',\n    'delim'   =\n ':',\n]);\n\n// IMAP is the same with and without folders:\n$mail = new Imap([\n    'host'     =\n 'example.com',\n    'user'     =\n 'test',\n    'password' =\n 'test',\n]);\n\n\n\n\nWith the method \ngetFolders($root = null)\n, you can get the folder hierarchy\nstarting with the root folder, or the given folder. The method returns an\ninstance of \nZend\\Mail\\Storage\\Folder\n, which implements \nRecursiveIterator\n,\nand all children are also instances of \nFolder\n. Each of these instances has a\nlocal and a global name returned by the methods \ngetLocalName()\n and\n\ngetGlobalName()\n. The global name is the absolute name from the root folder\n(including delimiters); the local name is the name in the parent folder.\n\n\nIf you use the iterator, the key of the current element is the local name. The\nglobal name is also returned by the magic method \n__toString()\n. Some folders\nmay not be selectable, which means they can't store messages; selecting them\nresults in an error. This can be checked with the method \nisSelectable()\n.\n\n\nThe following demonstrates providing a tree view of a folder:\n\n\nuse RecursiveIteratorIterator;\n\n$folders = new RecursiveIteratorIterator(\n    $this-\nmail-\ngetFolders(),\n    RecursiveIteratorIterator::SELF_FIRST\n);\n\necho '\nselect name=\nfolder\n';\nforeach ($folders as $localName =\n $folder) {\n    $localName = str_pad('', $folders-\ngetDepth(), '-', STR_PAD_LEFT)\n        .  $localName;\n    echo '\noption';\n\n    if (! $folder-\nisSelectable()) {\n        echo ' disabled=\ndisabled\n';\n    }\n\n    printf(\n        ' value=\n%s\n%s\n/option\n',\n        htmlspecialchars($folder),\n        htmlspecialchars($localName)\n    );\n}\necho '\n/select\n';\n\n\n\n\nThe current selected folder is returned by the method \ngetSelectedFolder()\n.\nChanging the folder is done with the method \nselectFolder()\n, which needs the\n\nglobal name\n as a parameter. If you want to avoid writing delimiters, you can\nalso use the properties of a \nFolder\n instance:\n\n\n// depending on your mail storage and its settings $rootFolder-\nArchive-\n2005\n// is the same as:\n//  /Archive/2005\n//  Archive:2005\n//  INBOX.Archive.2005\n//  ...\n$folder = $mail-\ngetFolders()-\nArchive-\n2005;\nprintf(\nLast folder was %s; new folder is %s\\n\n, $mail-\ngetSelectedFolder(), $folder);\n$mail-\nselectFolder($folder);\n\n\n\n\nAdvanced Use\n\n\nUsing NOOP\n\n\nIf you're using a remote storage and have some long tasks, you might need to\nkeep the connection alive via noop:\n\n\nforeach ($mail as $message) {\n\n    // do some calculations ...\n\n    $mail-\nnoop(); // keep alive\n\n    // do something else ...\n\n    $mail-\nnoop(); // keep alive\n}\n\n\n\n\nCaching instances\n\n\nZend\\Mail\\Storage\\Mbox\n, \nZend\\Mail\\Storage\\Folder\\Mbox\n,\n\nZend\\Mail\\Storage\\Maildir\n, and \nZend\\Mail\\Storage\\Folder\\Maildir\n implement the\nmagic methods \n__sleep()\n and \n__wakeup()\n, which means they are serializable.\n\n\nSerialization avoids parsing files and directory trees multiple times. The\ndisadvantage is that your mbox or maildir storage should not change; as such,\nits best used with static storage.\n\n\nYou can combine serialization with writable storage in a number of ways:\n\n\n\n\nCheck the current mbox file for modification time changes.\n\n\nReparse the folder structure if a folder has vanished (which still results in\n  an error, but you can search for another folder afterwards).\n\n\nCreate a signal file whenever a change is made; check for that signal file,\n  reparse if present, and remove it afterwards.\n\n\n\n\nuse Zend\\Mail\\Storage\\Folder\\Mbox;\n\n// There's no specific cache handler/class used here,\n// change the code to match your cache handler.\n$signalFile  = '/home/test/.mail.last_change';\n$mboxBasedir = '/home/test/mail/';\n$cacheId     = 'example mail cache ' . $mboxBasedir . $signalFile;\n$cache       = new Cache();\n$hasCache    = ($cache-\nhas($cacheId)\n    \n filemtime($signalFile) \n= $cache-\ngetMTime($cacheId)\n);\n\n$mail        = $hasCache\n    ? $cache-\nget($cacheId)\n    : new Mbox(['dirname' =\n $mboxBasedir]);\n\n// do stuff ...\n\n// Cache when done\n$cache-\nset($cacheId, $mail);\n\n\n\n\nExtending Protocol Classes\n\n\nRemote storage adapters use two classes: \nZend\\Mail\\Storage\\\nName\n and\n\nZend\\Mail\\Protocol\\\nName\n. The protocol class translates the protocol commands\nand responses from and to PHP, like methods for the commands or variables with\ndifferent structures for data. The storage class implements the common\ninterface for message access.\n\n\nIf you need additional protocol features, you can extend the protocol class and\nuse it in the constructor of the main class. As an example, assume we need to\nknock different ports before we can connect to POP3.\n\n\nnamespace Example\\Mail\n{\n    use Zend\\Mail;\n\n    class Exception extends Mail\\Exception\n    {\n    }\n}\n\nnamespace Example\\Mail\\Protocol\n{\n    use Zend\\Mail\\Protocol;\n\n    class Exception extends Protocol\\Exception\n    {\n    }\n}\n\nnamespace Example\\Mail\\Protocol\\Pop3\n{\n    use Zend\\Mail\\Protocol\\Pop3;\n\n    class Knock extends Pop3\n    {\n        private $host\n\n        private $port;\n\n        public function __construct($host, $port = null)\n        {\n            // no auto connect in this class\n            $this-\nhost = $host;\n            $this-\nport = $port;\n        }\n\n        public function knock($port)\n        {\n            $sock = @fsockopen($this-\nhost, $port);\n            if ($sock) {\n                fclose($sock);\n            }\n        }\n\n        public function connect($host = null, $port = null, $ssl = false)\n        {\n            if ($host === null) {\n                $host = $this-\nhost;\n            }\n            if ($port === null) {\n                $port = $this-\nport;\n            }\n            parent::connect($host, $port);\n        }\n    }\n}\n\nnamespace Example\\Mail\\Pop3\n{\n    use Example\\Mail\\Protoco\\Pop3\\Knock as KnockProtocol;\n    use Zend\\Mail\\Storage\\Pop3;\n\n    class Knock extends Pop3\n    {\n        public function __construct(array $params)\n        {\n            // ... check $params here! ...\n            $protocol = new KnockProtocol($params['host']);\n\n            // do our \nspecial\n thing\n            foreach ((array) $params['knock_ports'] as $port) {\n                $protocol-\nknock($port);\n            }\n\n            // get to correct state\n            $protocol-\nconnect($params['host'], $params['port']);\n            $protocol-\nlogin($params['user'], $params['password']);\n\n            // initialize parent\n            parent::__construct($protocol);\n        }\n    }\n}\n\n$mail = new Example\\Mail\\Pop3\\Knock([\n    'host'        =\n 'localhost',\n    'user'        =\n 'test',\n    'password'    =\n 'test',\n    'knock_ports' =\n [1101, 1105, 1111],\n]);\n\n\n\n\nThe above assumes a connection is made; when connected, it logs in and, if\nsupported, selects a folder as provided to the constructor.  When defining your\nown protocol class, make sure that's done or the next method will fail if the\nserver doesn't allow it in the current state.\n\n\nUsing Quotas\n\n\nZend\\Mail\\Storage\\Writable\\Maildir\n has support for Maildir++ quotas. It's\ndisabled by default, but it's possible to use it manually, if the automatic\nchecks are not desired (this means \nappendMessage()\n, \nremoveMessage()\n, and\n\ncopyMessage()\n do no checks and do not add entries to the maildirsize file). If\nenabled, an exception is thrown if you try to write to the maildir and it's\nalready over quota.\n\n\nThere are three methods used for quotas: \ngetQuota()\n, \nsetQuota()\n, and\n\ncheckQuota()\n:\n\n\nuse Zend\\Mail\\Storage\\Writable\\Maildir;\n\n$mail = new Maildir(['dirname' =\n '/home/test/mail/']);\n$mail-\nsetQuota(true); // true to enable, false to disable\n\nprintf(\nQuota check is now %s\\n\n, $mail-\ngetQuota() ? 'enabled' : 'disabled');\n\n// Check quota can be used even if quota checks are disabled:\nprintf(\nYou are %sover quota\\n\n, $mail-\ncheckQuota() ? '' : 'not ');\n\n\n\n\ncheckQuota()\n can also return a more detailed response by passing a boolean\n\ntrue\n argument:\n\n\n$quota = $mail-\ncheckQuota(true);\nprintf(\nYou are %sover quota\\n\n, $quota['over_quota'] ? '' : 'not ');\nprintf(\n    \nYou have %d of %d messages and use %d of %d octets\\n\n,\n    $quota['count'],\n    $quota['quota']['count'],\n    $quota['size'],\n    $quota['quota']['size']\n);\n\n\n\n\nIf you want to specify your own quota instead of using the one specified in the\nmaildirsize file, you can do with \nsetQuota()\n:\n\n\n// Message count and octet size supported; order does matter.\n$quota = $mail-\nsetQuota(['size' =\n 10000, 'count' =\n 100]);\n\n\n\n\nTo add your own quota checks, use single letters as keys, and they will be\npreserved (but obviously not checked). It's also possible to extend\n\nZend\\Mail\\Storage\\Writable\\Maildir\n to define your own quota if the maildirsize\nfile is missing (which can happen in Maildir++):\n\n\nnamespace Example\\Mail\\Storage;\n\nuse Zend\\Mail\\Storage\\Exception;\nuse Zend\\Mail\\Storage\\Writable\\Maildir as BaseMaildir;\n\nclass Maildir extends BaseMaildir\n{\n    /**\n     * getQuota is called with $fromStorage = true by quota checks.\n     *\n     * @param bool $fromStorage\n     * @return bool|array\n     */\n    public function getQuota($fromStorage = false) {\n        try {\n            return parent::getQuota($fromStorage);\n        } catch (Exception $e) {\n            if (! $fromStorage) {\n                // unknown error:\n                throw $e;\n            }\n\n            // maildirsize file must be missing\n            list($count, $size) = get_quota_from_somewhere_else();\n            return ['count' =\n $count, 'size' =\n $size];\n        }\n    }\n}", 
            "title": "Reading and Storing Mail"
        }, 
        {
            "location": "/read/#reading-and-storing-mail", 
            "text": "zend-mail can read mail messages from several local or remote mail storage\ntypes. Storage adapters share the same API for counting and fetching messages,\nand some of them implement additional interfaces for less common features. For a\nfeature overview of the implemented storages, see the following table.     Feature  Mbox  Maildir  Pop3  IMAP      Storage type  local  local  remote  remote    Fetch message  Yes  Yes  Yes  Yes    Fetch MIME-part  emulated  emulated  emulated  emulated    Folders  Yes  Yes  No  Yes    Create message/folder  No  todo  No  todo    Flags  No  Yes  No  Yes    Quota  No  Yes  No  No     Storage adapters return instances of  Zend\\Mail\\Storage\\Message , which has a\ndifferent API than  messages used when sending ; the API is\ndescribed in the  \"Working with messages\"  section.", 
            "title": "Reading and Storing Mail"
        }, 
        {
            "location": "/read/#basic-pop3-example", 
            "text": "use Zend\\Mail\\Storage\\Pop3;\n\n$mail = Pop3([\n    'host'     =  'localhost',\n    'user'     =  'test',\n    'password' =  'test',\n]);\n\necho $mail- countMessages() .   messages found\\n ;\nforeach ($mail as $message) {\n    printf( Mail from '%s': %s\\n , $message- from, $message- subject);\n}", 
            "title": "Basic POP3 example"
        }, 
        {
            "location": "/read/#using-local-storage-via-mbox-and-maildir", 
            "text": "Mbox and Maildir are the two supported formats for local mail storage.  If you want to read from an mbox file, provide the filename to the constructor\nof  Zend\\Mail\\Storage\\Mbox :  use Zend\\Mail\\Storage\\Mbox;\n\n$mail = new Mbox(['filename' =  '/home/test/mail/inbox']);  Maildir operates similarly, but requires a dirname instead:  use Zend\\Mail\\Storage\\Maildir;\n$mail = new Maildir(['dirname' =  '/home/test/mail/']);  Both constructors throw a  Zend\\Mail\\Exception  if the storage can't be read.", 
            "title": "Using local storage via mbox and maildir"
        }, 
        {
            "location": "/read/#using-remote-storage-protocols", 
            "text": "For remote storage, the two most popular protocols are supported: POP3 and IMAP.\nBoth need at least a host and a user to connect and login. The default password\nis an empty string, and the default port for the protocol is used if none is\nprovided.  use Zend\\Mail\\Storage\\Imap;\nuse Zend\\Mail\\Storage\\Pop3;\n\n// Connecting with Pop3:\n$mail = Pop3([\n    'host'     =  'example.com',\n    'user'     =  'test',\n    'password' =  'test',\n]);\n\n// Connecting with Imap:\n$mail = new Imap([\n    'host'     =  'example.com',\n    'user'     =  'test',\n    'password' =  'test',\n]);\n\n// Example of using POP3 on a non-standard port:\n$mail = new Pop3([\n    'host'     =  'example.com',\n    'port'     =  1120,\n    'user'     =  'test',\n    'password' =  'test',\n]);  Both storage adapters support SSL and TLS. If you use SSL, the default port\nchanges as specified in the relevant RFC.  use Zend\\Mail\\Storage\\Pop3;\n\n// Examples use Pop3; the same configuration works for Imap.\n\n// Use SSL on a non-standard port (default is 995 for Pop3 and 993 for Imap)\n$mail = new Pop3([\n    'host'     =  'example.com',\n    'user'     =  'test',\n    'password' =  'test',\n    'ssl'      =  'SSL',\n]);\n\n// use TLS on the default port:\n$mail = new Pop3([\n    'host'     =  'example.com',\n    'user'     =  'test',\n    'password' =  'test',\n    'ssl'      =  'TLS',\n]);  Both constructors throw  Zend\\Mail\\Exception  or  Zend\\Mail\\Protocol\\Exception \n(extends  Zend\\Mail\\Exception ) for connection errors, depending on the type of\nerror encountered.", 
            "title": "Using remote storage protocols"
        }, 
        {
            "location": "/read/#fetching-counting-and-removing-messages", 
            "text": "Once you have opened the mail storage, you may fetch messages. To do so, you\nneed the message number, which is a counter starting with 1 for the first\nmessage. To fetch the message, you use the method  getMessage() :  $message = $mail- getMessage($messageNum);  Array access is also supported, but this access method does not support any\nadditional parameters that could be added to  getMessage() . As long as you\ndon't mind, and can live with the default values, you may use:  $message = $mail[$messageNum];  For iterating over all messages the  Iterator  interface is implemented:  foreach ($mail as $messageNum =  $message) {\n    // do stuff ...\n}  To count the messages in the storage, you can use the method countMessages() ; alternately, storage adapters implement  Countable , allowing\nyou to  count()  the instance.  // method\n$maxMessage = $mail- countMessages();\n\n// array access\n$maxMessage = count($mail);  To remove a mail, use the method  removeMessage() , or rely on array access and\nuse  unset() :  // method\n$mail- removeMessage($messageNum);\n\n// array access\nunset($mail[$messageNum]);", 
            "title": "Fetching, counting, and removing messages"
        }, 
        {
            "location": "/read/#working-with-messages", 
            "text": "After you fetch a message, you can:   fetch headers  fetch the message content  fetch individual parts of multipart messages   All headers can be accessed as message instance properties or via the method getHeader() ; use the latter for messages with compound names.  Header names\nare normalized to lowercase internally, but may be fetched using any case\nstructure; dash-separated headers may be fetched using camelCase notation. If no\nheader matching the name is found, an exception is thrown; use the headerExists()  method (or  isset($message- headerName) ) to test for header\nexistence prior to retrieval.  // get the message object\n$message = $mail- getMessage(1);\n\n// output subject of message\necho $message- subject .  \\n ;\n\n// get content-type header\n$type = $message- contentType;\n\n// check if CC isset:\nif (isset($message- cc)) { // or $message- headerExists('cc');\n    $cc = $message- cc;\n}  If you have multiple headers with the same name   e.g. the  Received \nheaders   you will want an array of values. Property access always returns\na string, so use  getHeader()  instead for these situations:  // get header as property - the result is always a string,\n// with new lines between each value.\n$received = $message- received;\n\n// The same via getHeader() method:\n$received = $message- getHeader('received', 'string');\n\n// To retrieve an array of values:\n$received = $message- getHeader('received', 'array');\nforeach ($received as $line) {\n    // do stuff\n}\n\n// If you don't define a format you'll get the internal representation\n// (string for single headers, array for multiple):\n$received = $message- getHeader('received');\nif (is_string($received)) {\n    // only one received header found in message\n}  The method  getHeaders()  returns all headers as an array with the lower-cased\nname as the key and the value as an array for multiple headers or as string for\nsingle headers.  // dump all headers\nforeach ($message- getHeaders() as $name =  $value) {\n    if (is_string($value)) {\n        echo  $name: $value\\n ;\n        continue;\n    }\n    foreach ($value as $entry) {\n        echo  $name: $entry\\n ;\n    }\n}  If you don't have a multipart message, fetch the content via  getContent() .\nUnlike headers, the content is only fetched when needed (aka late-fetch).  // output message content for HTML\necho ' pre ';\necho $message- getContent();\necho ' /pre ';  Checking for multipart messages is done with the method  isMultipart() . If you\nhave a multipart message you, can get retrieve the individual Zend\\Mail\\Storage\\Part  instances making up the message via the  getPart() \nmethod, which accepts the part index as a parameter (indices start with 1). Zend\\Mail\\Storage\\Part  is the base class of  Zend\\Mail\\Storage\\Message , and\nthus exposes the same API with regards to headers, content, and retrieving\nnested parts.  // get the first non-multipart part\n$part = $message;\nwhile ($part- isMultipart()) {\n    $part = $message- getPart(1);\n}\necho 'Type of this part is ' . strtok($part- contentType, ';') .  \\n ;\necho  Content:\\n ;\necho $part- getContent();  Zend\\Mail\\Storage\\Part  also implements  RecursiveIterator , which allows iterating\nthrough all parts, even when nested. Additionally, it implements the magic\nmethod  __toString() , which returns the content.  use RecursiveIteratorIterator;\nuse Zend\\Mail\\Exception;\n\n// output first text/plain part\n$foundPart = null;\nforeach (new RecursiveIteratorIterator($mail- getMessage(1)) as $part) {\n    try {\n        if (strtok($part- contentType, ';') == 'text/plain') {\n            $foundPart = $part;\n            break;\n        }\n    } catch (Exception $e) {\n        // ignore\n    }\n}\nif (! $foundPart) {\n    echo 'no plain text part found';\n} else {\n    echo  plain text part: \\n  . $foundPart;\n}", 
            "title": "Working with messages"
        }, 
        {
            "location": "/read/#checking-for-flags", 
            "text": "Maildir and IMAP support storing flags with messages. The  Zend\\Mail\\Storage \nclass defines constants for all known maildir and IMAP system flags, named FLAG_ flagname . To check for flags,  Zend\\Mail\\Storage\\Message  has\na method called  hasFlag() . With  getFlags()  you'll get all flags.  use Zend\\Mail\\Storage;\n\n// Find unread messages:\necho  Unread mails:\\n ;\nforeach ($mail as $message) {\n    if ($message- hasFlag(Storage::FLAG_SEEN)) {\n        continue;\n    }\n\n    // mark recent/new mails\n    echo ($message- hasFlag(Storage::FLAG_RECENT))\n        ? '! '\n        : '  ';\n\n    echo $message- subject .  \\n ;\n}\n\n// Check for known flags\n$flags = $message- getFlags();\necho 'Message is flagged as: ';\nforeach ($flags as $flag) {\n    switch ($flag) {\n        case Storage::FLAG_ANSWERED:\n            echo 'Answered ';\n            break;\n        case Storage::FLAG_FLAGGED:\n            echo 'Flagged ';\n            break;\n\n        // ...\n        // check for other flags\n        // ...\n\n        default:\n            echo $flag . '(unknown flag) ';\n    }\n}  As IMAP allows user or client defined flags, you could get flags that don't have\na constant in  Zend\\Mail\\Storage . Instead, they are returned as strings and can\nbe checked the same way with  hasFlag() .  // check message for client defined flags $IsSpam, $SpamTested\nif (! $message- hasFlag('$SpamTested')) {\n    echo 'message has not been tested for spam';\n} elseif ($message- hasFlag('$IsSpam')) {\n    echo 'this message is spam';\n} else {\n    echo 'this message is ham';\n}", 
            "title": "Checking for flags"
        }, 
        {
            "location": "/read/#using-folders", 
            "text": "All storage adapters except POP3 support folders (also called  mailboxes ). The\ninterface implemented by all aadapters supporting folders is called Zend\\Mail\\Storage\\Folder\\FolderInterface . Each also supports an optional\nconfiguration parameter called  folder , which is the folder selected after\nlogin.  For the local storage adapters, you need to use the adapter-specific folder\nclasses,  Zend\\Mail\\Storage\\Folder\\Mbox  and  Zend\\Mail\\Storage\\Folder\\Maildir .\nEach accepts a single parameter,  dirname , with the name of the base direcor.\nThe format for maildir is as defined in maildir++  (with a dot as\ndefault delimiter); mbox uses a directory hierarchy of mbox files. If you don't\nhave an mbox file called  INBOX  in your mbox base directory, you need to\nspecify another folder via the constructor.  Zend\\Mail\\Storage\\Imap  supports folders by default.  Examples for opening folders with each adapter:  use Zend\\Mail\\Storage\\Folder;\nuse Zend\\Mail\\Storage\\Imap;\n\n// mbox with folders:\n$mail = Folder\\Mbox(['dirname' =  '/home/test/mail/']);\n\n// mbox with a default folder not called INBOX; also works\n// with the maildir and IMAP implemenations.\n$mail = new Folder\\Mbox([\n    'dirname' =  '/home/test/mail/',\n    'folder'  =  'Archive',\n]);\n\n// maildir with folders:\n$mail = new Folder\\Maildir(['dirname' =  '/home/test/mail/']);\n\n// maildir with colon as delimiter, as suggested in Maildir++:\n$mail = new Folder\\Maildir([\n    'dirname' =  '/home/test/mail/',\n    'delim'   =  ':',\n]);\n\n// IMAP is the same with and without folders:\n$mail = new Imap([\n    'host'     =  'example.com',\n    'user'     =  'test',\n    'password' =  'test',\n]);  With the method  getFolders($root = null) , you can get the folder hierarchy\nstarting with the root folder, or the given folder. The method returns an\ninstance of  Zend\\Mail\\Storage\\Folder , which implements  RecursiveIterator ,\nand all children are also instances of  Folder . Each of these instances has a\nlocal and a global name returned by the methods  getLocalName()  and getGlobalName() . The global name is the absolute name from the root folder\n(including delimiters); the local name is the name in the parent folder.  If you use the iterator, the key of the current element is the local name. The\nglobal name is also returned by the magic method  __toString() . Some folders\nmay not be selectable, which means they can't store messages; selecting them\nresults in an error. This can be checked with the method  isSelectable() .  The following demonstrates providing a tree view of a folder:  use RecursiveIteratorIterator;\n\n$folders = new RecursiveIteratorIterator(\n    $this- mail- getFolders(),\n    RecursiveIteratorIterator::SELF_FIRST\n);\n\necho ' select name= folder ';\nforeach ($folders as $localName =  $folder) {\n    $localName = str_pad('', $folders- getDepth(), '-', STR_PAD_LEFT)\n        .  $localName;\n    echo ' option';\n\n    if (! $folder- isSelectable()) {\n        echo ' disabled= disabled ';\n    }\n\n    printf(\n        ' value= %s %s /option ',\n        htmlspecialchars($folder),\n        htmlspecialchars($localName)\n    );\n}\necho ' /select ';  The current selected folder is returned by the method  getSelectedFolder() .\nChanging the folder is done with the method  selectFolder() , which needs the global name  as a parameter. If you want to avoid writing delimiters, you can\nalso use the properties of a  Folder  instance:  // depending on your mail storage and its settings $rootFolder- Archive- 2005\n// is the same as:\n//  /Archive/2005\n//  Archive:2005\n//  INBOX.Archive.2005\n//  ...\n$folder = $mail- getFolders()- Archive- 2005;\nprintf( Last folder was %s; new folder is %s\\n , $mail- getSelectedFolder(), $folder);\n$mail- selectFolder($folder);", 
            "title": "Using folders"
        }, 
        {
            "location": "/read/#advanced-use", 
            "text": "", 
            "title": "Advanced Use"
        }, 
        {
            "location": "/read/#using-noop", 
            "text": "If you're using a remote storage and have some long tasks, you might need to\nkeep the connection alive via noop:  foreach ($mail as $message) {\n\n    // do some calculations ...\n\n    $mail- noop(); // keep alive\n\n    // do something else ...\n\n    $mail- noop(); // keep alive\n}", 
            "title": "Using NOOP"
        }, 
        {
            "location": "/read/#caching-instances", 
            "text": "Zend\\Mail\\Storage\\Mbox ,  Zend\\Mail\\Storage\\Folder\\Mbox , Zend\\Mail\\Storage\\Maildir , and  Zend\\Mail\\Storage\\Folder\\Maildir  implement the\nmagic methods  __sleep()  and  __wakeup() , which means they are serializable.  Serialization avoids parsing files and directory trees multiple times. The\ndisadvantage is that your mbox or maildir storage should not change; as such,\nits best used with static storage.  You can combine serialization with writable storage in a number of ways:   Check the current mbox file for modification time changes.  Reparse the folder structure if a folder has vanished (which still results in\n  an error, but you can search for another folder afterwards).  Create a signal file whenever a change is made; check for that signal file,\n  reparse if present, and remove it afterwards.   use Zend\\Mail\\Storage\\Folder\\Mbox;\n\n// There's no specific cache handler/class used here,\n// change the code to match your cache handler.\n$signalFile  = '/home/test/.mail.last_change';\n$mboxBasedir = '/home/test/mail/';\n$cacheId     = 'example mail cache ' . $mboxBasedir . $signalFile;\n$cache       = new Cache();\n$hasCache    = ($cache- has($cacheId)\n      filemtime($signalFile)  = $cache- getMTime($cacheId)\n);\n\n$mail        = $hasCache\n    ? $cache- get($cacheId)\n    : new Mbox(['dirname' =  $mboxBasedir]);\n\n// do stuff ...\n\n// Cache when done\n$cache- set($cacheId, $mail);", 
            "title": "Caching instances"
        }, 
        {
            "location": "/read/#extending-protocol-classes", 
            "text": "Remote storage adapters use two classes:  Zend\\Mail\\Storage\\ Name  and Zend\\Mail\\Protocol\\ Name . The protocol class translates the protocol commands\nand responses from and to PHP, like methods for the commands or variables with\ndifferent structures for data. The storage class implements the common\ninterface for message access.  If you need additional protocol features, you can extend the protocol class and\nuse it in the constructor of the main class. As an example, assume we need to\nknock different ports before we can connect to POP3.  namespace Example\\Mail\n{\n    use Zend\\Mail;\n\n    class Exception extends Mail\\Exception\n    {\n    }\n}\n\nnamespace Example\\Mail\\Protocol\n{\n    use Zend\\Mail\\Protocol;\n\n    class Exception extends Protocol\\Exception\n    {\n    }\n}\n\nnamespace Example\\Mail\\Protocol\\Pop3\n{\n    use Zend\\Mail\\Protocol\\Pop3;\n\n    class Knock extends Pop3\n    {\n        private $host\n\n        private $port;\n\n        public function __construct($host, $port = null)\n        {\n            // no auto connect in this class\n            $this- host = $host;\n            $this- port = $port;\n        }\n\n        public function knock($port)\n        {\n            $sock = @fsockopen($this- host, $port);\n            if ($sock) {\n                fclose($sock);\n            }\n        }\n\n        public function connect($host = null, $port = null, $ssl = false)\n        {\n            if ($host === null) {\n                $host = $this- host;\n            }\n            if ($port === null) {\n                $port = $this- port;\n            }\n            parent::connect($host, $port);\n        }\n    }\n}\n\nnamespace Example\\Mail\\Pop3\n{\n    use Example\\Mail\\Protoco\\Pop3\\Knock as KnockProtocol;\n    use Zend\\Mail\\Storage\\Pop3;\n\n    class Knock extends Pop3\n    {\n        public function __construct(array $params)\n        {\n            // ... check $params here! ...\n            $protocol = new KnockProtocol($params['host']);\n\n            // do our  special  thing\n            foreach ((array) $params['knock_ports'] as $port) {\n                $protocol- knock($port);\n            }\n\n            // get to correct state\n            $protocol- connect($params['host'], $params['port']);\n            $protocol- login($params['user'], $params['password']);\n\n            // initialize parent\n            parent::__construct($protocol);\n        }\n    }\n}\n\n$mail = new Example\\Mail\\Pop3\\Knock([\n    'host'        =  'localhost',\n    'user'        =  'test',\n    'password'    =  'test',\n    'knock_ports' =  [1101, 1105, 1111],\n]);  The above assumes a connection is made; when connected, it logs in and, if\nsupported, selects a folder as provided to the constructor.  When defining your\nown protocol class, make sure that's done or the next method will fail if the\nserver doesn't allow it in the current state.", 
            "title": "Extending Protocol Classes"
        }, 
        {
            "location": "/read/#using-quotas", 
            "text": "Zend\\Mail\\Storage\\Writable\\Maildir  has support for Maildir++ quotas. It's\ndisabled by default, but it's possible to use it manually, if the automatic\nchecks are not desired (this means  appendMessage() ,  removeMessage() , and copyMessage()  do no checks and do not add entries to the maildirsize file). If\nenabled, an exception is thrown if you try to write to the maildir and it's\nalready over quota.  There are three methods used for quotas:  getQuota() ,  setQuota() , and checkQuota() :  use Zend\\Mail\\Storage\\Writable\\Maildir;\n\n$mail = new Maildir(['dirname' =  '/home/test/mail/']);\n$mail- setQuota(true); // true to enable, false to disable\n\nprintf( Quota check is now %s\\n , $mail- getQuota() ? 'enabled' : 'disabled');\n\n// Check quota can be used even if quota checks are disabled:\nprintf( You are %sover quota\\n , $mail- checkQuota() ? '' : 'not ');  checkQuota()  can also return a more detailed response by passing a boolean true  argument:  $quota = $mail- checkQuota(true);\nprintf( You are %sover quota\\n , $quota['over_quota'] ? '' : 'not ');\nprintf(\n     You have %d of %d messages and use %d of %d octets\\n ,\n    $quota['count'],\n    $quota['quota']['count'],\n    $quota['size'],\n    $quota['quota']['size']\n);  If you want to specify your own quota instead of using the one specified in the\nmaildirsize file, you can do with  setQuota() :  // Message count and octet size supported; order does matter.\n$quota = $mail- setQuota(['size' =  10000, 'count' =  100]);  To add your own quota checks, use single letters as keys, and they will be\npreserved (but obviously not checked). It's also possible to extend Zend\\Mail\\Storage\\Writable\\Maildir  to define your own quota if the maildirsize\nfile is missing (which can happen in Maildir++):  namespace Example\\Mail\\Storage;\n\nuse Zend\\Mail\\Storage\\Exception;\nuse Zend\\Mail\\Storage\\Writable\\Maildir as BaseMaildir;\n\nclass Maildir extends BaseMaildir\n{\n    /**\n     * getQuota is called with $fromStorage = true by quota checks.\n     *\n     * @param bool $fromStorage\n     * @return bool|array\n     */\n    public function getQuota($fromStorage = false) {\n        try {\n            return parent::getQuota($fromStorage);\n        } catch (Exception $e) {\n            if (! $fromStorage) {\n                // unknown error:\n                throw $e;\n            }\n\n            // maildirsize file must be missing\n            list($count, $size) = get_quota_from_somewhere_else();\n            return ['count' =  $count, 'size' =  $size];\n        }\n    }\n}", 
            "title": "Using Quotas"
        }
    ]
}